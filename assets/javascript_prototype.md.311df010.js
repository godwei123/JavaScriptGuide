import{_ as s,c as a,o as n,V as l}from"./chunks/framework.25f281e8.js";const p="/javascript-guide/assets/640-20220731210952948.4ce8d7a8.jpeg",o="/javascript-guide/assets/640-20220731211005039.4b0c175a.jpeg",e="/javascript-guide/assets/640-20220731211042445.04e5d6af.jpeg",t="/javascript-guide/assets/640-20220731211107908.73af7f2a.jpeg",c="/javascript-guide/assets/640-20220731211201809.e66085d4.jpeg",f=JSON.parse('{"title":"原型与原型链","description":"","frontmatter":{},"headers":[],"relativePath":"javascript/prototype.md","filePath":"javascript/prototype.md"}'),r={name:"javascript/prototype.md"},i=l(`<h1 id="原型与原型链" tabindex="-1">原型与原型链 <a class="header-anchor" href="#原型与原型链" aria-label="Permalink to &quot;原型与原型链&quot;">​</a></h1><p>JavaScript 中的对象有一个特殊的[[Prototype]]内置属性，其实就是对于其他对象的引用。几乎所有的对象在创建时[[Prototype]] 属性都会被赋予一个非空的值。</p><p>Object.create(..)的原理，它会创建一个对象并把这个对象的[[Prototype]]关联到指定的对象。</p><p>使用 for..in 遍历对象时原理和查找[[Prototype]]链类似，任何可以通过原型链访问到（并且是 enumerable）的属性都会被枚举。</p><p>使用 in 操作符来检查属性在对象中是否存在时，同样会查找对象的整条原型链**（无论属性是否可枚举）**</p><p>对原型链上层属性赋值存在 3 种情况：</p><ul><li>该属性只读，不可赋值，严格模式报错，非严格模式忽略该操作</li><li>该属性存在 setter，调用 setter 赋值</li><li>如果不是以上两种情况，在下层创建同名的属性并赋值，屏蔽上层属性。</li></ul><p><strong>隐式屏蔽</strong></p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> another </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">a</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> myObj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">create</span><span style="color:#A6ACCD;">(another)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(another</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">a)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 2</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(myObj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">a)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 2</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(another</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">hasOwnProperty</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">a</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">))</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// true</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(myObj</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">hasOwnProperty</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">a</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">))</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// false</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">myObj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">a</span><span style="color:#89DDFF;">++;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 隐式屏蔽</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(another</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">a)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 2</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(myObj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">a)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 3</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(another</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">hasOwnProperty</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">a</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">))</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// true</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(myObj</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">hasOwnProperty</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">a</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">))</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// true</span></span></code></pre></div><p>所有的函数默认都会拥有一个名为 prototype 的公有并且不可枚举的属性，它会指向另一个对象。</p><p>继承意味着复制操作，JavaScript（默认）并不会复制对象属性。相反，JavaScript 会在两个对象之间创建一个关联，这样一个对象就可以通过委托访问另一个对象的属性和函数。</p><p>实际上，函数本身并不是构造函数，然而，当你在普通的函数调用前面加上 new 关键字之后，就会把这个函数调用变成一个“构造函数调用”。实际上，new 会劫持所有普通函数并用构造对象的形式来调用它。</p><p>换句话说，在 JavaScript 中对于“构造函数”最准确的解释是，所有带 new 的函数调用。函数不是构造函数，但是当且仅当使用 new 时，函数调用会变成“构造函数调用”。</p><h2 id="call" tabindex="-1">call <a class="header-anchor" href="#call" aria-label="Permalink to &quot;call&quot;">​</a></h2><p><strong>.call.call</strong> 到底在为谁疯狂打 call？</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">fn1</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#F78C6C;">1</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">fn2</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#F78C6C;">2</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">fn1</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">call</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">call</span><span style="color:#A6ACCD;">(fn2)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 2</span></span></code></pre></div><p>所以 <strong>fn1.call.call(fn2)</strong> 等效于 <code>fn2.call(undefined)</code>。而且无论您加多少个 <strong>.call</strong>，效果也是一样的。</p><p><code>fn.call === Function.call // true</code></p><p>1:这个方法是在哪开始执行的 call(fn2); 2:执行后的结果是什么 call(fn2) 前面的 this 改成了 fn2 前面方法照常执行; 3:call(fn2) 前面是什么，改变 this 后会怎样 call(fn2) 前面是 fn1.call 改变 this 后 由于 fn1 是这次的行为主体(this)，是他执行了 call 方法，所以 fn1 被 call(fn2) 变成了 fn2，所以接下来执行的就是 fn2.call(); 4:输出 fn2 this: [object Window].</p><ol><li>前面的一串 <code>fn.call.call.call.call</code> 并没有调用，只是获取对象的 call 属性，所以，这一串的结果是 Function.call 属性。</li><li>所以那一串就是 <code>Function.call.call(fn2)</code>；还可以解理为 fn3.call(fn2)。</li><li>根据 call 的原理（可参考上面的 call 模拟），在 fn3 执行 call，其实际是这样执行的 <code>fn2.fn3()</code>。</li><li>由于 fn3 实际上就是 call 函数，所以, fn2.fn3() 等价于 <code>fn2.call()</code>。</li><li>所以，上面那一串代码的最终结果，就是调用 fn2，所以结果输出 2.</li></ol><h3 id="实例后的对象也能再次实例吗" tabindex="-1">实例后的对象也能再次实例吗？ <a class="header-anchor" href="#实例后的对象也能再次实例吗" aria-label="Permalink to &quot;实例后的对象也能再次实例吗？&quot;">​</a></h3><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">People</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> lili </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">People</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// People {}</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> lucy </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> tom</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">constructor</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// People {}</span></span></code></pre></div><p>es6 函数带默认参数时将生成<strong>声明作用域</strong></p><p>函数表达式（非函数声明）中的函数名不可覆盖。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> c </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">CC</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">CC</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">123</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">CC</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#82AAFF;">c</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// Function</span></span></code></pre></div><p>当然，如果设置 <code>var CC = 123</code> ，加声明关键词是可以覆盖的。</p><h1 id="继承" tabindex="-1">继承 <a class="header-anchor" href="#继承" aria-label="Permalink to &quot;继承&quot;">​</a></h1><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">Object.setPrototypeOf(Bar.prototype,Foo.prototype)</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">Bar.prototype = Object.create(Foo.prototype)</span></span></code></pre></div><p>如果使用内置的．bind(..)函数来生成一个硬绑定函数的话，该函数是没有 prototype 属性的</p><p>instanceof</p><p>Foo.prototype.isPrototypeOf(a) // a 的整条[[Prototype]]是否出现过 Foo.prototype</p><p>Object.getPrototypeOf(obj) 获取一个对象的[[Prototype]]链</p><p>Object.setPrototypeOf(obj1,obj2) 设置属性</p><p>Object.create(..)会创建一个新对象（bar）并把它关联到我们指定的对象（foo），这样我们就可以充分发挥[[Prototype]] 机制的威力（委托）并且避免不必要的麻烦（比如使用 new 的构造函数调用会生成．prototype 和．constructor 引用）。</p><p>Object.create(null)会创建一个拥有空（或者说 null）[[Prototype]]链接的对象，这个对象无法进行委托。由于这个对象没有原型链，所以 instanceof 操作符（之前解释过）无法进行判断，因此总是会返回 false。这些特殊的空[[Prototype]] 对象通常被称作“字典”，它们完全不会受到原型链的干扰，因此非常适合用来存储数据。</p><p>Object.create(..)的第二个参数指定了需要添加到新对象中的属性名以及这些属性的属性描述符。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">create</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">o</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">function</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">F</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#FFCB6B;">F</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">o</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">new</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">F</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span></code></pre></div><h3 id="class-语法糖" tabindex="-1"><code>class</code> 语法糖 <a class="header-anchor" href="#class-语法糖" aria-label="Permalink to &quot;\`class\` 语法糖&quot;">​</a></h3><p><code>class</code> 语法糖到底是怎么继承的？</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">function Super() {</span></span>
<span class="line"><span style="color:#A6ACCD;">  this.a = 1;</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">function Child() {</span></span>
<span class="line"><span style="color:#A6ACCD;">  // 属性继承</span></span>
<span class="line"><span style="color:#A6ACCD;">  Super.call(this);</span></span>
<span class="line"><span style="color:#A6ACCD;">  this.b = 2;</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">// 原型继承</span></span>
<span class="line"><span style="color:#A6ACCD;">Child.prototype = new Super();</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">const child = new Child();</span></span>
<span class="line"><span style="color:#A6ACCD;">child.a;  // 1</span></span></code></pre></div><p>正式代码的原型继承，不会直接实例父类，而是实例一个空函数，避免重复声明动态属性</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">const extends = (Child, Super) =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">  const fn = function () {};</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">  fn.prototype = Super.prototype;</span></span>
<span class="line"><span style="color:#A6ACCD;">  Child.prototype = new fn();</span></span>
<span class="line"><span style="color:#A6ACCD;">  Child.prototype.constructor = Child;</span></span>
<span class="line"><span style="color:#A6ACCD;">};</span></span></code></pre></div><h3 id="es5-有几种方式可以实现继承-分别有哪些优缺点" tabindex="-1"><strong>ES5 有几种方式可以实现继承？分别有哪些优缺点？</strong> <a class="header-anchor" href="#es5-有几种方式可以实现继承-分别有哪些优缺点" aria-label="Permalink to &quot;**ES5 有几种方式可以实现继承？分别有哪些优缺点？**&quot;">​</a></h3><h5 id="_1-原型链继承" tabindex="-1">1. 原型链继承 <a class="header-anchor" href="#_1-原型链继承" aria-label="Permalink to &quot;1. 原型链继承&quot;">​</a></h5><p>原型链继承的基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。</p><p><img src="`+p+'" alt="图片"></p><p>缺点：</p><ol><li>通过原型来实现继承时，原型会变成另一个类型的实例，原先的实例属性变成了现在的原型属性，该原型的引用类型属性会被所有的实例共享。</li><li>在创建子类型的实例时，没有办法在不影响所有对象实例的情况下给超类型的构造函数中传递参数。</li></ol><h5 id="_2-借用构造函数" tabindex="-1">2. 借用构造函数 <a class="header-anchor" href="#_2-借用构造函数" aria-label="Permalink to &quot;2. 借用构造函数&quot;">​</a></h5><p><strong>借用构造函数</strong>的技术，其基本思想为:</p><p>在子类型的构造函数中调用超类型构造函数。</p><p><img src="'+o+'" alt="图片"></p><p>优点:</p><ol><li>可以向超类传递参数</li><li>解决了原型中包含引用类型值被所有实例共享的问题</li></ol><p>缺点:</p><ol><li>方法都在构造函数中定义，函数复用无从谈起，另外超类型原型中定义的方法对于子类型而言都是不可见的。</li></ol><h5 id="_3-组合继承-原型链-借用构造函数" tabindex="-1">3. 组合继承(原型链 + 借用构造函数) <a class="header-anchor" href="#_3-组合继承-原型链-借用构造函数" aria-label="Permalink to &quot;3. 组合继承(原型链 + 借用构造函数)&quot;">​</a></h5><p>组合继承指的是将原型链和借用构造函数技术组合到一块，从而发挥二者之长的一种继承模式。基本思路：</p><p>使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承，既通过在原型上定义方法来实现了函数复用，又保证了每个实例都有自己的属性。</p><p><img src="'+e+'" alt="图片"></p><p>缺点:</p><ul><li>无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。</li></ul><p>优点:</p><ul><li>可以向超类传递参数</li><li>每个实例都有自己的属性</li><li>实现了函数复用</li></ul><h5 id="_4-原型式继承" tabindex="-1">4. 原型式继承 <a class="header-anchor" href="#_4-原型式继承" aria-label="Permalink to &quot;4. 原型式继承&quot;">​</a></h5><p>原型继承的基本思想：</p><p>借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。</p><p><img src="'+t+'" alt="图片"></p><p>在 <code>object()</code> 函数内部，先穿甲一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例，从本质上讲， <code>object()</code> 对传入的对象执行了一次浅拷贝。</p><p>ECMAScript5 通过新增 <code>Object.create()</code> 方法规范了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象( 可以覆盖原型对象上的同名属性)，在传入一个参数的情况下， <code>Object.create()</code> 和 <code>object()</code> 方法的行为相同。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn5w5xjuwSNcwNxibl5v5eI18VraG9B6xHDCM4nibm2M2E2Ebue7RIVmAgw/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>在没有必要创建构造函数，仅让一个对象与另一个对象保持相似的情况下，原型式继承是可以胜任的。</p><p>缺点:</p><p>同原型链实现继承一样，包含引用类型值的属性会被所有实例共享。</p><h5 id="_5-寄生式继承" tabindex="-1">5. 寄生式继承 <a class="header-anchor" href="#_5-寄生式继承" aria-label="Permalink to &quot;5. 寄生式继承&quot;">​</a></h5><p>寄生式继承是与原型式继承紧密相关的一种思路。寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部已某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。</p><p><img src="'+c+'" alt="图片"></p><p>基于 <code>person</code> 返回了一个新对象 -—— <code>person2</code>，新对象不仅具有 <code>person</code> 的所有属性和方法，而且还有自己的 <code>sayHi()</code> 方法。在考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。</p><p>缺点：</p><ul><li>使用寄生式继承来为对象添加函数，会由于不能做到函数复用而效率低下。</li><li>同原型链实现继承一样，包含引用类型值的属性会被所有实例共享。</li></ul><h5 id="_6-寄生组合式继承" tabindex="-1">6. 寄生组合式继承 <a class="header-anchor" href="#_6-寄生组合式继承" aria-label="Permalink to &quot;6. 寄生组合式继承&quot;">​</a></h5><p>所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法，基本思路：</p><p>不必为了指定子类型的原型而调用超类型的构造函数，我们需要的仅是超类型原型的一个副本，本质上就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。寄生组合式继承的基本模式如下所示：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn59eJo9qQWjQQAiauRvo7ezc2ILiayI7uUTj4rLxYBz989k42Lj87pqRdg/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><ul><li>第一步：创建超类型原型的一个副本</li><li>第二步：为创建的副本添加 <code>constructor</code> 属性</li><li>第三步：将新创建的对象赋值给子类型的原型</li></ul><p>至此，我们就可以通过调用 <code>inheritPrototype</code> 来替换为子类型原型赋值的语句：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn5G4zK1DvgwSiaO6hl7TDmslABvXPhVhLrg4qWYbl9lm5uVSC5MQ7LayQ/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>优点:</p><p>只调用了一次超类构造函数，效率更高。避免在 <code>SuberType.prototype</code>上面创建不必要的、多余的属性，与其同时，原型链还能保持不变。</p><p>因此寄生组合继承是引用类型最理性的继承范式。</p><h2 id="委托" tabindex="-1">委托 <a class="header-anchor" href="#委托" aria-label="Permalink to &quot;委托&quot;">​</a></h2><p>委托行为意味着某些对象在找不到属性或者方法引用时会把这个请求委托给另一个对象。</p><p>匿名函数没有 name 标识符，这会导致： 1．调试栈更难追踪； 2．自我引用（递归、事件（解除）绑定，等等）更难； 3．代码（稍微）更难理解。</p><p>使用简洁方法时一定要小心这一点。如果你需要自我引用的话，那最好使用传统的具名函数表达式来定义对应的函数（· baz: function baz(){..}·），不要使用简洁方法。</p><p>行为委托认为对象之间是兄弟关系，互相委托，而不是父类和子类的关系。JavaScript 的[[Prototype]]机制本质上就是行为委托机制。也就是说，我们可以选择在 JavaScript 中努力实现类机制，也可以拥抱更自然的[[Prototype]]委托机制。</p><h4 id="描述下-javascript-中-scope-作用域-、closure-闭包-、prototype-原型-概念" tabindex="-1">描述下 JavaScript 中 Scope（作用域）、Closure（闭包）、Prototype（原型） 概念 <a class="header-anchor" href="#描述下-javascript-中-scope-作用域-、closure-闭包-、prototype-原型-概念" aria-label="Permalink to &quot;描述下 JavaScript 中 Scope（作用域）、Closure（闭包）、Prototype（原型） 概念&quot;">​</a></h4><p><strong>作用域</strong>负责收集和维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。</p><ul><li>全局作用域</li><li>函数作用域</li><li>块级作用域</li></ul><h5 id="闭包的定义" tabindex="-1">闭包的定义 <a class="header-anchor" href="#闭包的定义" aria-label="Permalink to &quot;闭包的定义&quot;">​</a></h5><p>《JavaScript 高级程序设计》:闭包是指有权访问另一个函数作用域中的变量的函数</p><p>《JavaScript 权威指南》：从技术的角度讲，所有的 JavaScript 函数都是闭包：它们都是对象，它们都关联到作用域链。</p><p>《你不知道的 JavaScript》：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。</p><h5 id="闭包的作用" tabindex="-1">闭包的作用 <a class="header-anchor" href="#闭包的作用" aria-label="Permalink to &quot;闭包的作用&quot;">​</a></h5><ul><li>能够访问函数定义时所在的词法作用域(阻止其被回收)。</li><li>私有化变量</li><li>模拟块级作用域</li><li>创建模块</li></ul><h2 id="说明-javascript-封装、继承实现原理" tabindex="-1">说明 JavaScript 封装、继承实现原理 <a class="header-anchor" href="#说明-javascript-封装、继承实现原理" aria-label="Permalink to &quot;说明 JavaScript 封装、继承实现原理&quot;">​</a></h2><h3 id="_2-如何正确判断-this-的指向" tabindex="-1"><strong>2. 如何正确判断 this 的指向？</strong> <a class="header-anchor" href="#_2-如何正确判断-this-的指向" aria-label="Permalink to &quot;**2. 如何正确判断 this 的指向？**&quot;">​</a></h3><p>如果用一句话说明 this 的指向，那么即是: 谁调用它，this 就指向谁。</p><p>但是仅通过这句话，我们很多时候并不能准确判断 this 的指向。因此我们需要借助一些规则去帮助自己：</p><p>this 的指向可以按照以下顺序判断:</p><h4 id="全局环境中的-this" tabindex="-1">全局环境中的 this <a class="header-anchor" href="#全局环境中的-this" aria-label="Permalink to &quot;全局环境中的 this&quot;">​</a></h4><p>浏览器环境：无论是否在严格模式下，在全局执行环境中（在任何函数体外部）this 都指向全局对象 <code>window</code>;</p><p>node 环境：无论是否在严格模式下，在全局执行环境中（在任何函数体外部），this 都是空对象 <code>{}</code>;</p><h4 id="是否是-new-绑定" tabindex="-1">是否是 <code>new</code> 绑定 <a class="header-anchor" href="#是否是-new-绑定" aria-label="Permalink to &quot;是否是 `new` 绑定&quot;">​</a></h4><p>如果是 <code>new</code> 绑定，并且构造函数中没有返回 function 或者是 object，那么 this 指向这个新对象。如下:</p><p>构造函数返回值不是 function 或 object。 <code>newSuper()</code> 返回的是 this 对象。</p><p>构造函数返回值是 function 或 object， <code>newSuper()</code>是返回的是 Super 种返回的对象。</p><h4 id="函数是否通过-call-apply-调用-或者使用了-bind-绑定-如果是-那么-this-绑定的就是指定的对象【归结为显式绑定】。" tabindex="-1">函数是否通过 call,apply 调用，或者使用了 bind 绑定，如果是，那么 this 绑定的就是指定的对象【归结为显式绑定】。 <a class="header-anchor" href="#函数是否通过-call-apply-调用-或者使用了-bind-绑定-如果是-那么-this-绑定的就是指定的对象【归结为显式绑定】。" aria-label="Permalink to &quot;函数是否通过 call,apply 调用，或者使用了 bind 绑定，如果是，那么 this 绑定的就是指定的对象【归结为显式绑定】。&quot;">​</a></h4><p>这里同样需要注意一种<strong>特殊</strong>情况，如果 call,apply 或者 bind 传入的第一个参数值是 <code>undefined</code>或者 <code>null</code>，严格模式下 this 的值为传入的值 null /undefined。非严格模式下，实际应用的默认绑定规则，this 指向全局对象(node 环境为 global，浏览器环境为 window)</p><h4 id="隐式绑定-函数的调用是在某个对象上触发的-即调用位置上存在上下文对象。典型的隐式调用为-xxx-fn" tabindex="-1">隐式绑定，函数的调用是在某个对象上触发的，即调用位置上存在上下文对象。典型的隐式调用为: <code>xxx.fn()</code> <a class="header-anchor" href="#隐式绑定-函数的调用是在某个对象上触发的-即调用位置上存在上下文对象。典型的隐式调用为-xxx-fn" aria-label="Permalink to &quot;隐式绑定，函数的调用是在某个对象上触发的，即调用位置上存在上下文对象。典型的隐式调用为: `xxx.fn()`&quot;">​</a></h4><h4 id="默认绑定-在不能应用其它绑定规则时使用的默认规则-通常是独立函数调用。" tabindex="-1">默认绑定，在不能应用其它绑定规则时使用的默认规则，通常是独立函数调用。 <a class="header-anchor" href="#默认绑定-在不能应用其它绑定规则时使用的默认规则-通常是独立函数调用。" aria-label="Permalink to &quot;默认绑定，在不能应用其它绑定规则时使用的默认规则，通常是独立函数调用。&quot;">​</a></h4><p>非严格模式：node 环境，执行全局对象 global，浏览器环境，执行全局对象 window。</p><p>严格模式：执行 undefined</p><h4 id="箭头函数的情况" tabindex="-1">箭头函数的情况： <a class="header-anchor" href="#箭头函数的情况" aria-label="Permalink to &quot;箭头函数的情况：&quot;">​</a></h4><p>箭头函数没有自己的 this，继承外层上下文绑定的 this。（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。</p><h4 id="继承-1" tabindex="-1">继承 <a class="header-anchor" href="#继承-1" aria-label="Permalink to &quot;继承&quot;">​</a></h4><p>实现方式：将子类的原型链指向父类的对象实例 原理：子类实例 child 的<code>__proto__</code>指向 Child 的原型链 prototype，而 Child.prototype 指向 Parent 类的对象实例，该父类对象实例的<code>__proto__</code>指向 Parent.prototype,所以 Child 可继承 Parent 的构造函数属性、方法和原型链属性、方法 优点：可继承构造函数的属性，父类构造函数的属性，父类原型的属性 缺点：无法向父类构造函数传参；且所有实例共享父类实例的属性，若父类共有属性为引用类型，一个子类实例更改父类构造函数共有属性时会导致继承的共有属性发生变化；</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">Child</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Parent</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p>（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。</p><p>实现方式：在子类构造函数中使用 call 或者 apply 劫持父类构造函数方法，并传入参数 原理：使用 call 或者 apply 更改子类函数的作用域，使 this 执行父类构造函数，子类因此可以继承父类共有属性 优点：可解决原型链继承的缺点 缺点：不可继承父类的原型链方法，构造函数不可复用</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">Parent</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">call</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">this</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p>（3）第三种方式是组合继承</p><p>，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。</p><p>实现方式：综合使用构造函数继承和原型链继承 优点：可继承父类原型上的属性，且可传参；每个新实例引入的构造函数是私有的 缺点：会执行两次父类的构造函数，消耗较大内存，子类的构造函数会代替原型上的那个父类构造函数</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">Child</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Parent</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#A6ACCD;">Parent</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">call</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">this</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p>（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。</p><p>原理：类似 Object.create，用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象，结果是将子对象的<code>__proto__</code> 指向父对象 缺点：共享引用类型</p><p>（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是自定义类型时。缺点是没有办法实现函数的复用。</p><p>（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。</p><p>ES6 中有关 <code>class</code> 的继承方式，引入了 <code>extends</code> 关键字。但其本质仍然是 <code>构造函数</code> + <code>原型链的</code> 组合式继承。</p>',139),y=[i];function D(A,C,F,d,h,u){return n(),a("div",null,y)}const m=s(r,[["render",D]]);export{f as __pageData,m as default};
