import{_ as t,c as s,o as a,Q as l}from"./chunks/framework.00751356.js";const g=JSON.parse('{"title":"HTML 属性","description":"","frontmatter":{},"headers":[],"relativePath":"basic/html/attribute.md","filePath":"basic/html/attribute.md"}'),e={name:"basic/html/attribute.md"},o=l(`<h1 id="html-属性" tabindex="-1">HTML 属性 <a class="header-anchor" href="#html-属性" aria-label="Permalink to &quot;HTML 属性&quot;">​</a></h1><h2 id="defer-async" tabindex="-1">defer &amp; async <a class="header-anchor" href="#defer-async" aria-label="Permalink to &quot;defer &amp; async&quot;">​</a></h2><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">script</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">defer</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">src</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;&quot;</span><span style="color:#E1E4E8;">&gt;&lt;/</span><span style="color:#85E89D;">script</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">script</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">async</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">src</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;&quot;</span><span style="color:#E1E4E8;">&gt;&lt;/</span><span style="color:#85E89D;">script</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">script</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">defer</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">src</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;&quot;</span><span style="color:#24292E;">&gt;&lt;/</span><span style="color:#22863A;">script</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">script</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">async</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">src</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;&quot;</span><span style="color:#24292E;">&gt;&lt;/</span><span style="color:#22863A;">script</span><span style="color:#24292E;">&gt;</span></span></code></pre></div><p>使用 async 属性和 defer 属性都可以异步加载外部的 JS 文件，不会阻塞 DOM 的解析。</p><p><strong>async</strong> 表示应该立即开始下载脚本，但不能阻止其他页面动作。<strong>加载好后立即执行</strong>。多个带 async 属性的标签，<strong>不能保证加载的顺序</strong>。</p><p><strong>defer</strong> 表示在文档解析和显示完成后再执行脚本是没有问题的。<strong>html 解析完成之后才会立即执行代码</strong>。多个带 defer 属性的标签，<strong>按照顺序执行</strong>。</p><h2 id="src-与-href-的区别" tabindex="-1">src 与 href 的区别 <a class="header-anchor" href="#src-与-href-的区别" aria-label="Permalink to &quot;src 与 href 的区别&quot;">​</a></h2><p>src 用于替换当前元素，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求 src 资源时会将其指向的资源下载并应用到文档内，例如 js 脚本，img 图片和 frame 等元素。</p><p>当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将 js 脚本放在底部而不是头部。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">script</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">scr</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;index.js&quot;</span><span style="color:#E1E4E8;">&gt;&lt;/</span><span style="color:#85E89D;">script</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">script</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">scr</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;index.js&quot;</span><span style="color:#24292E;">&gt;&lt;/</span><span style="color:#22863A;">script</span><span style="color:#24292E;">&gt;</span></span></code></pre></div><p>href 用于在当前文档和引用资源之间确立联系。指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">link</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">href</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;index.css&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">rel</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;stylesheet&quot;</span><span style="color:#E1E4E8;"> /&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">link</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">href</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;index.css&quot;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">rel</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;stylesheet&quot;</span><span style="color:#24292E;"> /&gt;</span></span></code></pre></div><p>那么浏览器会识别该文档为 css 文件，就会并行下载资源并且不会停止对当前文档的处理。 这也是为什么建议使用 link 方式来加载 css，而不是使用@import 方式。</p><h2 id="target-属性" tabindex="-1">target 属性 <a class="header-anchor" href="#target-属性" aria-label="Permalink to &quot;target 属性&quot;">​</a></h2><p>_self: <strong>当前页面加载</strong>，即当前的响应到同一 HTML 4 frame（或 HTML5 浏览上下文）。此值是默认的，如果没有指定属性的话。</p><p>_blank: <strong>新窗口打开</strong>，即到一个新的未命名的 HTML4 窗口或 HTML5 浏览器上下文</p><p>_parent: 加载响应到当前框架的 HTML4 父框架或当前的 HTML5 浏览上下文的<strong>父浏览上下文</strong>。如果没有 parent 框架或者浏览上下文，此选项的行为方式与 _self 相同。</p><p>_top: HTML4 中：加载的响应成完整的，原来的窗口，取消所有其它 frame。 HTML5 中：加载响应进入顶层浏览上下文（即，浏览上下文，它是当前的一个的祖先，并且没有 parent）。如果没有 parent 框架或者浏览上下文，此选项的行为方式相同_self</p><h2 id="html5-drag-api" tabindex="-1">HTML5 drag API <a class="header-anchor" href="#html5-drag-api" aria-label="Permalink to &quot;HTML5 drag API&quot;">​</a></h2><p>Drag Source 被拖放元素 / Drag Target 目标元素</p><ul><li>dragstart：事件主体是<strong>被拖放元素</strong>，在开始拖放被拖放元素时触发。🤔</li><li>drag：事件主体是<strong>被拖放元素</strong>，在正在拖放被拖放元素时触发。</li><li>dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。</li><li>dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。🤔</li><li>dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。</li><li>drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。🤔</li><li>dragend：事件主体是<strong>被拖放元素</strong>，在整个拖放操作结束时触发。</li></ul><blockquote><p>记得要针对 <code>dragover</code> 取消预设行为（preventDefault），否則可能无法正确触发 drop 事件。</p></blockquote><p>给需要拖拽的对象设置属性 draggable=“true”</p><h2 id="可替换元素-空-void-元素" tabindex="-1">可替换元素/空（void）元素 <a class="header-anchor" href="#可替换元素-空-void-元素" aria-label="Permalink to &quot;可替换元素/空（void）元素&quot;">​</a></h2><p>可替换元素 : 可替换元素是指元素内容的展现不是由 CSS 来控制的，而是外观渲染独立于 CSS 的外部对象。</p><p><strong>典型的可替换元素有</strong>: <code>&lt;img&gt;、&lt;iframe&gt;、&lt;video&gt;、&lt;embed&gt;</code></p><p>空元素：没有内容的 HTML 元素。常见的有：br、meta、hr、link、input、img</p><h2 id="link-和-import" tabindex="-1">link 和 @import <a class="header-anchor" href="#link-和-import" aria-label="Permalink to &quot;link 和 @import&quot;">​</a></h2><ol><li>link 是 XHTML 标签，除了加载 CSS 外，还可以定义 RSS 等其他事务；@import 属于 CSS 范畴，只能加载 CSS。</li><li>link 引用 CSS 时，在页面载入时同时加载；@import 需要页面网页完全载入以后加载。</li><li>link 无兼容问题；@import 是在 CSS2.1 提出的，低版本的浏览器不支持。</li><li>link 支持使用 Javascript 控制 DOM 去改变样式；而@import 不支持。</li></ol><h2 id="渐进增强和优雅降级" tabindex="-1">渐进增强和优雅降级 <a class="header-anchor" href="#渐进增强和优雅降级" aria-label="Permalink to &quot;渐进增强和优雅降级&quot;">​</a></h2><p>渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</p><p>优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</p><h2 id="附录" tabindex="-1">附录 <a class="header-anchor" href="#附录" aria-label="Permalink to &quot;附录&quot;">​</a></h2><h3 id="全局属性" tabindex="-1">全局属性 <a class="header-anchor" href="#全局属性" aria-label="Permalink to &quot;全局属性&quot;">​</a></h3><table><thead><tr><th>属性</th><th>属性</th><th>属性</th><th>属性</th><th>属性</th></tr></thead><tbody><tr><td>accesskey</td><td>autocapitalize</td><td>autofocus</td><td>class</td><td>contenteditable</td></tr><tr><td>data-*</td><td>dir</td><td>draggable</td><td>enterkeyhint</td><td>exportparts</td></tr><tr><td>hidden</td><td>id</td><td>inert</td><td>inputmode</td><td>is</td></tr><tr><td>itemid</td><td>itemprop</td><td>itemref</td><td>itemscope</td><td>itemtype</td></tr><tr><td>lang</td><td>nonce</td><td>part</td><td>slot</td><td>spellcheck</td></tr><tr><td>style</td><td>tabindex</td><td>title</td><td>translate</td><td></td></tr></tbody></table><h3 id="其他属性" tabindex="-1">其他属性 <a class="header-anchor" href="#其他属性" aria-label="Permalink to &quot;其他属性&quot;">​</a></h3><table><thead><tr><th>属性</th><th>属性</th><th>属性</th><th>属性</th><th>属性</th></tr></thead><tbody><tr><td>accept</td><td>autocomplete</td><td>capture</td><td>crossorigin</td><td>disabled</td></tr><tr><td>elementtiming</td><td>for</td><td>max</td><td>maxlength</td><td>min</td></tr><tr><td>minlength</td><td>multiple</td><td>pattern</td><td>readonly</td><td>rel</td></tr><tr><td>required</td><td>size</td><td>step</td><td></td><td></td></tr></tbody></table>`,37),n=[o];function r(p,d,c,i,h,y){return a(),s("div",null,n)}const u=t(e,[["render",r]]);export{g as __pageData,u as default};
