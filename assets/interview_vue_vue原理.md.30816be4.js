import{_ as e,c as o,o as a,V as p}from"./chunks/framework.25f281e8.js";const s="/javascript-guide/assets/20220715224607703.14803c02.png",g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"interview/vue/vue原理.md","filePath":"interview/vue/vue原理.md"}'),t={name:"interview/vue/vue原理.md"},l=p(`<h2 id="vue-原理" tabindex="-1">Vue 原理 <a class="header-anchor" href="#vue-原理" aria-label="Permalink to &quot;Vue 原理&quot;">​</a></h2><p>watch 和 computed</p><h3 id="响应式原理" tabindex="-1">响应式原理 <a class="header-anchor" href="#响应式原理" aria-label="Permalink to &quot;响应式原理&quot;">​</a></h3><p>组件中 data 数据变化会触发视图的更新。监听 data 属性的 getter 和 setter</p><p>实现数据驱动视图第一步。</p><p>核心 API：Object.defineProperty / Proxy</p><p>Object.defineProperty(对象, 属性, {配置})</p><ul><li>深度监听，递归实现，计算量大</li><li>无法监听新增和删除属性（Vue.set / Vue.delete）</li><li>无法原生监听数组，需要重新定义数组的原型进行监听</li></ul><h3 id="双向绑定的原理" tabindex="-1">双向绑定的原理 <a class="header-anchor" href="#双向绑定的原理" aria-label="Permalink to &quot;双向绑定的原理&quot;">​</a></h3><h3 id="虚拟-dom-diff" tabindex="-1">虚拟 DOM / diff <a class="header-anchor" href="#虚拟-dom-diff" aria-label="Permalink to &quot;虚拟 DOM / diff&quot;">​</a></h3><p>使用 JS 模拟 DOM 结构，计算最小变更，然后有效操作 DOM</p><p>虚拟 DOM 是一个对象（标签/属性/子元素）</p><p>优点：</p><ul><li>DOM 操作比较耗时</li><li>有了 vdom 之后，就没有和 dom 强绑定了，可以渲染到别的平台。</li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#FFCB6B;">type</span><span style="color:#89DDFF;">:</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">div</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#FFCB6B;">props</span><span style="color:#89DDFF;">:{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#FFCB6B;">id</span><span style="color:#89DDFF;">:</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">a</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#FFCB6B;">className</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;">[</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">b</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">c</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">]</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#FFCB6B;">onClick</span><span style="color:#89DDFF;">:</span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">(){}</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#FFCB6B;">children</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;">[]</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>直接写 vdom 太麻烦了，所以前端框架都会设计一套 dsl，然后编译成 render function，执行后产生 vdom。</p><p>渲染 vdom 也就是通过 dom api 增删改 dom。</p><p>diff 算法是 vdom 的核心、最关键的部分。</p><ul><li>只比较同层节点</li><li>tag 不同，则直接删除，不在删除重建</li><li>tag 和 key 都相同，则认为是同一个节点</li><li>h，vnode，patch，diff，key</li></ul><p>patch(elem, vnode)</p><p>patch(vnode, newVnode)</p><h3 id="模板编译" tabindex="-1">模板编译 <a class="header-anchor" href="#模板编译" aria-label="Permalink to &quot;模板编译&quot;">​</a></h3><p><strong>组件渲染和更新过程</strong></p><p>vue template complier 编译为 render 函数</p><p>执行 render 函数生成 vnode，基于 vnode 执行 patch 和 diff</p><p>使用 webpack，vue-loader 会在开发环境下编译模板，运行时已经不存在模板了</p><p>部分复杂情况，可能不能使用 template，会使用 render</p><ul><li>初次渲染：解析模板为 render 函数；触发响应式，监听 data 属性 getter 和 setter；执行 render 函数，生成 vnode，patch</li><li>更新渲染：修改 data，触发 setter（此前 getter 中已被监听）；重新执行 render，生成 newVnode；执行 patch</li><li>异步渲染：</li></ul><p>nextTick 待 DOM 渲染完成后回调。页面渲染会将 data 做整合，多次 data 修改只会渲染一次，减少 DOM 操作次数，提高性能。</p><p><img src="`+s+'" alt="image-20220715224607703"></p><p>我们无法直接追踪局部变量的读写过程，在原生 JavaScript 中没有提供这样一种机制。<strong>但是</strong>，我们是可以追踪一个<strong>对象的属性</strong> 进行读和写的。</p><p>在 JavaScript 中有两种劫持属性访问的方式：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get" target="_blank" rel="noreferrer">getter</a> /<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set" target="_blank" rel="noreferrer">setters</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noreferrer">Proxies</a>。Vue 2 使用 getter/setters 完全由于需支持更旧版本浏览器的限制。而在 Vue 3 中使用了 Proxy 来创建响应式对象，将 getter/setter 用于 ref。</p><ul><li>当你将一个响应性对象的属性解构为一个局部变量时，响应性就会“断开连接”，因为对局部变量的访问不再触发 get / set 代理捕获。</li><li>从 <code>reactive()</code> 返回的代理尽管行为上表现得像原始对象，但我们通过使用 <code>===</code> 运算符还是能够比较出它们的不同。</li></ul><p>一个运行时渲染器将会遍历整个虚拟 DOM 树，并据此构建真实的 DOM 树。这个过程被称为<strong>挂载 (mount)</strong>。</p><p>如果我们有两份虚拟 DOM 树，渲染器将会有比较地遍历它们，找出它们之间的区别，并应用这其中的变化到真实的 DOM 上。这个过程被称为<strong>修补 (patch)</strong>，又被称为“比较差异 (diffing)”或“协调 (reconciliation)”。</p><p>虚拟 DOM 带来的主要收益是它赋予了开发者编程式地、声明式地创建、审查和组合所需 UI 结构的能力，而把直接与 DOM 相关的操作交给了渲染器。</p><p>以更高层面的视角看，Vue 组件挂载后发生了如下这几件事：</p><ol><li><strong>编译</strong>：Vue 模板被编译为了<strong>渲染函数</strong>：即用来返回虚拟 DOM 树的函数。这一步骤可以通过构建步骤提前完成，也可以通过使用运行时编译器即时完成。</li><li><strong>挂载</strong>：运行时渲染器调用渲染函数，遍历返回的虚拟 DOM 树，并基于它创建实际的 DOM 节点。这一步会作为<a href="https://staging-cn.vuejs.org/guide/extras/reactivity-in-depth.html" target="_blank" rel="noreferrer">响应式副作用</a> 执行，因此它会追踪其中所用到的所有响应式依赖。</li><li><strong>修补</strong>：当一个依赖发生变化后，副作用会重新运行，这时候会创建一个更新后的虚拟 DOM 树。运行时渲染器遍历这棵新树，将它与旧树进行比较，然后将必要的更新应用到真实 DOM 上去。</li></ol><p>Vue 编译器用来提高虚拟 DOM 运行时性能的主要优化：</p><ol><li><p><strong>静态提升</strong> 在模板中常常有部分内容是不带任何动态绑定的，没有必要在重新渲染时再次创建和比对它们。此外，当有足够多连续的静态元素时，它们还会再被压缩为一个“静态 vnode”，其中包含的是这些节点相应的纯 HTML 字符串。这些静态节点会直接通过 <code>innerHTML</code> 来挂载。同时还会在初次挂载后缓存相应的 DOM 节点。如果这部分内容在应用中其他地方被重用，那么将会使用原生的 <code>cloneNode()</code> 方法来克隆新的 DOM 节点，这会非常高效。</p></li><li><p><strong>修补标记 Flags</strong></p><p>对于单个有动态绑定的元素来说，我们可以在编译时推断出大量信息：一个元素可以有多个修补标记，会被合并成一个数字。运行时渲染器也将会使用位运算来检查这些标记，确定相应的更新操作。</p></li><li><p><strong>树结构打平</strong></p><p>这里我们引入一个概念“区块”，内部结构是稳定的一个部分可被称之为一个区块。每一个块都会追踪其所有带修补标记的后代节点 ( 不只是直接子节点) 。编译的结果会被打平为一个数组，仅包含所有动态的后代节点。当这个组件需要重渲染时，只需要遍历这个打平的树而非整棵树。这也就是我们所说的** 树结构打平**，这大大减少了我们在虚拟 DOM 协调时需要遍历的节点数量。模板中任何的静态部分都会被高效地略过。<code>v-if</code> 和 <code>v-for</code> 指令会创建新的区块节点</p></li></ol><p>Vue2 与 Vue3 有哪些变化</p><ol><li><p>生命周期变化，功能上类似，写法上 on+名称；Vue3 组合式 API 需要先引入，选项 API 可直接调用；beforeCreate/created 在 Vue3 中取消，在 setup 中运行</p></li><li><p>多根节点，也就是<code>fragment</code>，Vue2 中，编写页面的时候，我们需要去将组件包裹在<code>&lt;div&gt;</code>中，否则报错警告。</p></li><li><p>异步组件。Vue3 提供 <code>Suspense</code>组件，允许程序在等待异步组件时渲染兜底的内容，如 loading ，使用户体验更平滑。 使用它，需在模板中声明，并包括两个命名插槽：<code>default</code>和<code>fallback</code>。<code>Suspense</code> 确保加载完异步内容时显示默认插槽，并将<code>fallback</code>插槽用作加载状态。</p></li><li><p><code>teleport</code> . Vue3 提供<code>Teleport</code>组件可将部分 DOM 移动到 Vue app 之外的位置。</p></li><li><p>组合式 API。Vue2 中一个逻辑会散乱在文件不同位置（data、props、computed、watch、生命周期函数等），导致代码的可读性变差，需要上下来回跳转文件位置。组合式 API 还提供了较为完美的逻辑复用性方案，解决了 Vue2 <code>Mixin</code>的存在的命名冲突隐患，依赖关系不明确，不同组件间配置化使用不够灵活。</p></li><li><p>响应式原理。Vue2 响应式原理基础是<code>Object.defineProperty</code>；Vue3 响应式原理基础是 <code>Proxy</code>。</p><p>主要原因：无法监听对象或数组新增、删除的元素。 Vue2 方案：针对常用数组原型方法<code>push</code>、<code>pop</code>、<code>shift</code>、<code>unshift</code>、<code>splice</code> 、<code>sort</code>、<code>reverse</code>进行了 hack 处理；提供<code>Vue.set</code>监听对象/数组新增属性。对象的新增/删除响应，还可以<code>new</code> 个新对象，新增则合并新属性和旧对象；删除则将删除属性后的对象深拷贝给新对象。</p><p><strong>Tips：</strong> <code>Object.defineOProperty</code>是可以监听数组已有元素，但 Vue2 没有提供的原因是<code>性能</code>问题</p><p>对象/数组的新增、删除。</p><p>监测.length 修改。</p><p>Map、Set、WeakMap、WeakSet 的支持。</p></li><li><p>虚拟 DOM。Vue3 相比于 Vue2 虚拟 DOM 上增加<code>patchFlag</code>字段。</p></li><li><p>事件缓存。Vue3 的 <code>cacheHandler</code>可在第一次渲染后缓存我们的事件。相比于 Vue2 无需每次渲染都传递一个新函数。加一个<code>click</code> 事件。</p></li><li><p>Diff 优化。patchFlag 帮助 diff 时区分静态节点，以及不同类型的动态节点。一定程度地减少节点本身及其属性的比对。</p></li><li><p>打包优化。tree-shaking，移除 JavaScript 上下文中未引用的代码。以<code>nextTick</code>为例子，在 Vue2 中，全局 API 暴露在 Vue 实例上，即使未使用，也无法通过<code>tree-shaking</code>进行消除。Vue3 中针对全局 和内部的 API 进行了重构，并考虑到<code>tree-shaking</code> 的支持。因此，全局 API 现在只能作为 ES 模块构建的命名导出进行访问。</p></li><li><p>TS 支持</p></li></ol><p>react 是通过 setState 的 api 触发状态更新的，更新以后就重新渲染整个 vdom。</p><p>而 vue 是通过对状态做代理，get 的时候收集以来，然后修改状态的时候就可以触发对应组件的 render 了。</p><p>那 vue 为啥可以做到精准的更新变化的组件呢？因为响应式的代理呀，不管是子组件、父组件、还是其他位置的组件，只要用到了对应的状态，那就会被作为依赖收集起来，状态变化的时候就可以触发它们的 render，不管是组件是在哪里的。</p><p>react 的 setState 会渲染整个 vdom，而一个应用的所有 vdom 可能是很庞大的，计算量就可能很大。</p><h3 id="fiber-架构" tabindex="-1"><strong>fiber 架构</strong> <a class="header-anchor" href="#fiber-架构" aria-label="Permalink to &quot;**fiber 架构**&quot;">​</a></h3><p>优化的目标是打断计算，分多次进行，但现在递归的渲染是不能打断的，有两个方面的原因导致的：</p><ul><li>渲染的时候直接就操作了 dom 了，这时候打断了，那已经更新到 dom 的那部分怎么办？</li><li>现在是直接渲染的 vdom，而 vdom 里只有 children 的信息，如果打断了，怎么找到它的父节点呢？</li></ul><p>第一个问题的解决还是容易想到的：渲染的时候不要直接更新到 dom 了，只找到变化的部分，打个增删改的标记，创建好 dom，等全部计算完了一次性更新到 dom 就好了。</p><p>所以 react 把渲染流程分为了两部分：render 和 commit。</p><p>render 阶段会找到 vdom 中变化的部分，创建 dom，打上增删改的标记，这个叫做 reconcile，调和。</p><p>reconcile 是可以打断的，由 schedule 调度。</p><p>之后全部计算完了，就一次性更新到 dom，叫做 commit。</p><p>这样，react 就把之前的和 vue 很像的递归渲染，改造成了 render（reconcile + schdule） + commit 两个阶段的渲染。</p><p>第二个问题，如何打断以后还能找到父节点、其他兄弟节点呢？</p><p>现有的 vdom 是不行的，需要再记录下 parent、silbing 的信息。所以 react 创造了 fiber 的数据结构。</p><p>除了 children 信息外，额外多了 sibling、return，分别记录着兄弟节点、父节点的信息。</p><p>这个数据结构也叫做 fiber。（fiber 既是一种数据结构，也代表 render + commit 的渲染流程）</p><p>react 会先把 vdom 转换成 fiber，再去进行 reconcile，这样就是可打断的了。</p><p>reconcile 的时候把有 effectTag 的节点收集到一个队列里，然后 commit 阶段直接遍历这个队列就行了。这个队列叫做 effectList。react 会在 commit 阶段遍历 effectList，根据 effectTag 来增删改 dom。</p><p>useEffect 被设计成了在 dom 操作前异步调用，useLayoutEffect 是在 dom 操作后同步调用。</p>',62),n=[l];function r(c,i,d,u,f,D){return a(),o("div",null,n)}const m=e(t,[["render",r]]);export{g as __pageData,m as default};
