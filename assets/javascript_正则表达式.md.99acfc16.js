import{_ as e,c as a,o as t,Q as o}from"./chunks/framework.00751356.js";const b=JSON.parse('{"title":"正则表达式","description":"","frontmatter":{},"headers":[],"relativePath":"javascript/正则表达式.md","filePath":"javascript/正则表达式.md"}'),r={name:"javascript/正则表达式.md"},s=o(`<h1 id="正则表达式" tabindex="-1">正则表达式 <a class="header-anchor" href="#正则表达式" aria-label="Permalink to &quot;正则表达式&quot;">​</a></h1><p>正则表达式是用于匹配字符串中字符组合的模式。在 JavaScript 中，正则表达式也是对象。这些模式被用于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp" target="_blank" rel="noreferrer"><code>RegExp</code></a> 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec" target="_blank" rel="noreferrer"><code>exec</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test" target="_blank" rel="noreferrer"><code>test</code></a> 方法, 以及 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String" target="_blank" rel="noreferrer"><code>String</code></a> 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/match" target="_blank" rel="noreferrer"><code>match</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/matchAll" target="_blank" rel="noreferrer"><code>matchAll</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace" target="_blank" rel="noreferrer"><code>replace</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/search" target="_blank" rel="noreferrer"><code>search</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/split" target="_blank" rel="noreferrer"><code>split</code></a> 方法。</p><h2 id="创建正则表达式" tabindex="-1">创建正则表达式 <a class="header-anchor" href="#创建正则表达式" aria-label="Permalink to &quot;创建正则表达式&quot;">​</a></h2><h3 id="_1、正则表达式字面量" tabindex="-1">1、正则表达式字面量 <a class="header-anchor" href="#_1、正则表达式字面量" aria-label="Permalink to &quot;1、正则表达式字面量&quot;">​</a></h3><p>使用一个正则表达式字面量，其由包含在斜杠之间的模式组成，如下所示：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> re </span><span style="color:#F97583;">=</span><span style="color:#DBEDFF;"> </span><span style="color:#9ECBFF;">/</span><span style="color:#DBEDFF;">ab</span><span style="color:#F97583;">+</span><span style="color:#DBEDFF;">c</span><span style="color:#9ECBFF;">/</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">var</span><span style="color:#24292E;"> re </span><span style="color:#D73A49;">=</span><span style="color:#032F62;"> /ab</span><span style="color:#D73A49;">+</span><span style="color:#032F62;">c/</span><span style="color:#24292E;">;</span></span></code></pre></div><p><strong>脚本加载后</strong>，正则表达式字面量就会被编译。</p><p>当正则表达式保持不变时，使用此方法可获得更好的性能。</p><h3 id="_2、调用regexp对象的构造函数" tabindex="-1">2、调用<code>RegExp</code>对象的构造函数， <a class="header-anchor" href="#_2、调用regexp对象的构造函数" aria-label="Permalink to &quot;2、调用\`RegExp\`对象的构造函数，&quot;">​</a></h3><p>如下所示：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> re </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">RegExp</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;ab+c&quot;</span><span style="color:#E1E4E8;">);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">var</span><span style="color:#24292E;"> re </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">RegExp</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;ab+c&quot;</span><span style="color:#24292E;">);</span></span></code></pre></div><p>在<strong>脚本运行过程中</strong>，用构造函数创建的正则表达式会被编译。</p><p>如果正则表达式将会改变，或者它将会从用户输入等来源中动态地产生，就需要使用构造函数来创建正则表达式。</p><h2 id="编写正则表达式的模式" tabindex="-1">编写正则表达式的模式 <a class="header-anchor" href="#编写正则表达式的模式" aria-label="Permalink to &quot;编写正则表达式的模式&quot;">​</a></h2><h3 id="_1、简单模式" tabindex="-1">1、简单模式 <a class="header-anchor" href="#_1、简单模式" aria-label="Permalink to &quot;1、简单模式&quot;">​</a></h3><p>简单模式是由你想直接找到的字符构成。比如，<code>/abc/</code> 这个模式就能且仅能匹配 &quot;abc&quot; 字符按照顺序同时出现的情况。例如在 &quot;Hi, do you know your abc&#39;s?&quot; 和 &quot;The latest airplane designs evolved from slabcraft.&quot; 中会匹配成功。在上述两个例子中，匹配的子字符串是 &quot;abc&quot;。但是在 &quot;Grab crab&quot; 中会匹配失败，因为它虽然包含子字符串 &quot;ab c&quot;，但并不是准确的 &quot;abc&quot;。</p><h3 id="_2、特殊字符" tabindex="-1">2、特殊字符 <a class="header-anchor" href="#_2、特殊字符" aria-label="Permalink to &quot;2、特殊字符&quot;">​</a></h3><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-backslash" target="_blank" rel="noreferrer">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-backslash</a></p></blockquote><p>| 字符 | 含义 | | :----------------------------------------------------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------ | | <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-backslash" target="_blank" rel="noreferrer"><code>\\</code></a> | 依照下列规则匹配：<br>在非特殊字符之前的反斜杠表示下一个字符是特殊字符，不能按照字面理解。例如，前面没有 &quot;\\&quot; 的 &quot;b&quot; 通常匹配小写字母 &quot;b&quot;，即字符会被作为字面理解，无论它出现在哪里。但如果前面加了 &quot;\\&quot;，它将不再匹配任何字符，而是表示一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#note" target="_blank" rel="noreferrer">字符边界</a>。<br>在特殊字符之前的反斜杠表示下一个字符不是特殊字符，应该按照字面理解。详情请参阅下文中的 &quot;转义（Escaping）&quot; 部分。<br>如果你想将字符串传递给 RegExp 构造函数，不要忘记在字符串字面量中反斜杠是转义字符。所以为了在模式中添加一个反斜杠，你需要在字符串字面量中转义它。<code>/[a-z]\\s/i</code> 和 <code>new RegExp(&quot;[a-z]\\\\s&quot;, &quot;i&quot;)</code> 创建了相同的正则表达式：一个用于搜索后面紧跟着空白字符（<code>\\s</code> 可看后文）并且在 a-z 范围内的任意字符的表达式。为了通过字符串字面量给 RegExp 构造函数创建包含反斜杠的表达式，你需要在字符串级别和正则表达式级别都对它进行转义。例如 <code>/[a-z]:\\\\/i</code> 和 <code>new RegExp(&quot;[a-z]:\\\\\\\\&quot;,&quot;i&quot;)</code> 会创建相同的表达式，即匹配类似 &quot;C:\\&quot; 字符串。 | | <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-caret" target="_blank" rel="noreferrer"><code>^</code></a> | 匹配输入的开始。如果多行标志被设置为 true，那么也匹配换行符后紧跟的位置。例如，<code>/^A/</code> 并不会匹配 &quot;an A&quot; 中的 &#39;A&#39;，但是会匹配 &quot;An E&quot; 中的 &#39;A&#39;。当 &#39;<code>^</code>&#39; 作为第一个字符出现在一个字符集合模式时，它将会有不同的含义。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-negated-character-set" target="_blank" rel="noreferrer">反向字符集合</a> 一节有详细介绍和示例。 | | <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-dollar" target="_blank" rel="noreferrer"><code>$</code></a> | 匹配输入的结束。如果多行标志被设置为 true，那么也匹配换行符前的位置。例如，<code>/t$/</code> 并不会匹配 &quot;eater&quot; 中的 &#39;t&#39;，但是会匹配 &quot;eat&quot; 中的 &#39;t&#39;。 | | <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-asterisk" target="_blank" rel="noreferrer"><code>*</code></a> | 匹配前一个表达式 0 次或多次。等价于 <code>{0,}</code>。例如，<code>/bo*/</code> 会匹配 &quot;A ghost boooooed&quot; 中的 &#39;booooo&#39; 和 &quot;A bird warbled&quot; 中的 &#39;b&#39;，但是在 &quot;A goat grunted&quot; 中不会匹配任何内容。 | | <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-plus" target="_blank" rel="noreferrer"><code>+</code></a> | 匹配前面一个表达式 1 次或者多次。等价于 <code>{1,}</code>。例如，<code>/a+/</code> 会匹配 &quot;candy&quot; 中的 &#39;a&#39; 和 &quot;caaaaaaandy&quot; 中所有的 &#39;a&#39;，但是在 &quot;cndy&quot; 中不会匹配任何内容。 | | <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-questionmark" target="_blank" rel="noreferrer"><code>?</code></a> | 匹配前面一个表达式 0 次或者 1 次。等价于 <code>{0,1}</code>。例如，<code>/e?le?/</code> 匹配 &quot;angel&quot; 中的 &#39;el&#39;、&quot;angle&quot; 中的 &#39;le&#39; 以及 &quot;oslo&#39; 中的 &#39;l&#39;。如果<strong>紧跟在任何量词 *、 +、? 或 {} 的后面</strong>，将会使量词变为<strong>非贪婪</strong>（匹配尽量少的字符），和缺省使用的<strong>贪婪模式</strong>（匹配尽可能多的字符）正好相反。例如，对 &quot;123abc&quot; 使用 <code>/\\d+/</code> 将会匹配 &quot;123&quot;，而使用 <code>/\\d+?/</code> 则只会匹配到 &quot;1&quot;。还用于先行断言中，如本表的 <code>x(?=y)</code> 和 <code>x(?!y)</code> 条目所述。 | | <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-dot" target="_blank" rel="noreferrer"><code>.</code></a> | （小数点）默认匹配除换行符之外的任何单个字符。例如，<code>/.n/</code> 将会匹配 &quot;nay, an apple is on the tree&quot; 中的 &#39;an&#39; 和 &#39;on&#39;，但是不会匹配 &#39;nay&#39;。如果 <code>s</code> (&quot;dotAll&quot;) 标志位被设为 true，它也会匹配换行符。 | | <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-capturing-parentheses" target="_blank" rel="noreferrer"><code>(x)</code></a> | 像下面的例子展示的那样，它会匹配 &#39;x&#39; 并且记住匹配项。其中括号被称为<em>捕获括号</em>。模式 <code>/(foo) (bar) \\1 \\2/</code> 中的 &#39;<code>(foo)</code>&#39; 和 &#39;<code>(bar)</code>&#39; 匹配并记住字符串 &quot;foo bar foo bar&quot; 中前两个单词。模式中的 <code>\\1</code> 和 <code>\\2</code> 表示第一个和第二个被捕获括号匹配的子字符串，即 <code>foo</code> 和 <code>bar</code>，匹配了原字符串中的后两个单词。注意 <code>\\1</code>、<code>\\2</code>、...、<code>\\n</code> 是用在正则表达式的匹配环节，详情可以参阅后文的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-backreference" target="_blank" rel="noreferrer">\\n</a> 条目。而在正则表达式的替换环节，则要使用像 <code>$1</code>、<code>$2</code>、...、<code>$n</code> 这样的语法，例如，<code>&#39;bar foo&#39;.replace(/(...) (...)/, &#39;$2 $1&#39;)</code>。<code>$&amp;</code> 表示整个用于匹配的原字符串。 | | <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-non-capturing-parentheses" target="_blank" rel="noreferrer"><code>(?:x)</code></a> | 匹配 &#39;x&#39; 但是不记住匹配项。这种括号叫作<em>非捕获括号</em>，使得你能够定义与正则表达式运算符一起使用的子表达式。看看这个例子 <code>/(?:foo){1,2}/</code>。如果表达式是 <code>/foo{1,2}/</code>，<code>{1,2}</code> 将只应用于 &#39;foo&#39; 的最后一个字符 &#39;o&#39;。如果使用非捕获括号，则 <code>{1,2}</code> 会应用于整个 &#39;foo&#39; 单词。更多信息，可以参阅下文的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Using_parentheses" target="_blank" rel="noreferrer">Using parentheses</a> 条目. | | <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-lookahead" target="_blank" rel="noreferrer"><code>x(?=y)</code></a> | **匹配&#39;x&#39;仅仅当&#39;x&#39;后面跟着&#39;y&#39;.这种叫做先行断言。**例如，/Jack(?=Sprat)/会匹配到&#39;Jack&#39;仅当它后面跟着&#39;Sprat&#39;。/Jack(?=Sprat|Frost)/匹配‘Jack’仅当它后面跟着&#39;Sprat&#39;或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。 | | <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-lookahead" target="_blank" rel="noreferrer"><code>(?&lt;=y)</code></a>x | **匹配&#39;x&#39;仅当&#39;x&#39;前面是&#39;y&#39;.这种叫做后行断言。**例如，/(?&lt;=Jack)Sprat/会匹配到&#39; Sprat &#39;仅仅当它前面是&#39; Jack &#39;。/(?&lt;=Jack|Tom)Sprat/匹配‘ Sprat ’仅仅当它前面是&#39;Jack&#39;或者是‘Tom’。但是‘Jack’和‘Tom’都不是匹配结果的一部分。 | | <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-negated-look-ahead" target="_blank" rel="noreferrer"><code>x(?!y)</code></a> | <strong>仅仅当&#39;x&#39;后面不跟着&#39;y&#39;时匹配&#39;x&#39;，这被称为正向否定查找</strong>。例如，仅仅当这个数字后面没有跟小数点的时候，/\\d+(?!.)/ 匹配一个数字。正则表达式/\\d+(?!.)/.exec(&quot;3.141&quot;)匹配‘141’而不是‘3.141’ | | <code>(?&lt;!*y*)*x*</code> | 仅仅当&#39;x&#39;前面不是&#39;y&#39;时匹配&#39;x&#39;，这被称为反向否定查找。例如, 仅仅当这个数字前面没有负号的时候，<code>/(?&lt;!-)\\d+/</code> 匹配一个数字。 <code>/(?&lt;!-)\\d+/.exec(&#39;3&#39;)</code> 匹配到 &quot;3&quot;. <code>/(?&lt;!-)\\d+/.exec(&#39;-3&#39;)</code> 因为这个数字前有负号，所以没有匹配到。 | | <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-or" target="_blank" rel="noreferrer"><code>x | y</code></a> | 匹配‘x’或者‘y’。例如，/green|red/匹配“green apple”中的‘green’和“red apple”中的‘red’ | | <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-quantifier" target="_blank" rel="noreferrer"><code>{n}</code></a> | n 是一个正整数，匹配了前面一个字符刚好出现了 n 次。 比如， /a{2}/ 不会匹配“candy”中的&#39;a&#39;,但是会匹配“caandy”中所有的 a，以及“caaandy”中的前两个&#39;a&#39;。 | | <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-quantifier" target="_blank" rel="noreferrer"><code>{n,}</code></a> | n 是一个正整数，匹配前一个字符至少出现了 n 次。例如, /a{2,}/ 匹配 &quot;aa&quot;, &quot;aaaa&quot; 和 &quot;aaaaa&quot; 但是不匹配 &quot;a&quot;。 | | <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-quantifier-range" target="_blank" rel="noreferrer"><code>{n,m}</code></a> | n 和 m 都是整数。匹配前面的字符至少 n 次，最多 m 次。如果 n 或者 m 的值是 0， 这个值被忽略。例如，/a{1, 3}/ 并不匹配“cndy”中的任意字符，匹配“candy”中的 a，匹配“caandy”中的前两个 a，也匹配“caaaaaaandy”中的前三个 a。注意，当匹配”caaaaaaandy“时，匹配的值是“aaa”，即使原始的字符串中有更多的 a。 | | <code>[xyz]</code> | 一个字符集合。匹配方括号中的任意字符，包括<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Grammar_and_types" target="_blank" rel="noreferrer">转义序列</a>。你可以使用破折号（-）来指定一个字符范围。对于点（.）和星号（*）这样的特殊符号在一个字符集中没有特殊的意义。他们不必进行转义，不过转义也是起作用的。 例如，[abcd] 和[a-d]是一样的。他们都匹配&quot;brisket&quot;中的‘b’,也都匹配“city”中的‘c’。/[a-z.]+/ 和/[\\w.]+/与字符串“test.i.ng”匹配。 | | <code>[^xyz]</code> | 一个反向字符集。也就是说， 它匹配任何没有包含在方括号中的字符。你可以使用破折号（-）来指定一个字符范围。任何普通字符在这里都是起作用的。例如，[^abc] 和 [^a-c] 是一样的。他们匹配&quot;brisket&quot;中的‘r’，也匹配“chop”中的‘h’。 | | <code>[\\b]</code> | 匹配一个退格(U+0008)。（不要和\\b 混淆了。） | | <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-word-boundary" target="_blank" rel="noreferrer"><code>\\b</code></a> | 匹配一个词的边界。一个词的边界就是一个词不被另外一个“字”字符跟随的位置或者前面跟其他“字”字符的位置，例如在字母和空格之间。注意，匹配中不包括匹配的字边界。换句话说，一个匹配的词的边界的内容的长度是 0。（不要和[\\b]混淆了）使用&quot;moon&quot;举例： /\\bm/匹配“moon”中的‘m’； /oo\\b/并不匹配&quot;moon&quot;中的&#39;oo&#39;，因为&#39;oo&#39;被一个“字”字符&#39;n&#39;紧跟着。 /oon\\b/匹配&quot;moon&quot;中的&#39;oon&#39;，因为&#39;oon&#39;是这个字符串的结束部分。这样他没有被一个“字”字符紧跟着。 /\\w\\b\\w/将不能匹配任何字符串，因为在一个单词中间的字符永远也不可能同时满足没有“字”字符跟随和有“字”字符跟随两种情况。<strong>备注：</strong> JavaScript 的正则表达式引擎将<a href="https://www.ecma-international.org/ecma-262/5.1/#sec-15.10.2.6" target="_blank" rel="noreferrer">特定的字符集</a>定义为“字”字符。不在该集合中的任何字符都被认为是一个断词。这组字符相当有限：它只包括大写和小写的罗马字母，十进制数字和下划线字符。不幸的是，重要的字符，例如“é”或“ü”，被视为断词。 | | <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-non-word-boundary" target="_blank" rel="noreferrer"><code>\\B</code></a> | 匹配一个非单词边界。匹配如下几种情况：字符串第一个字符为非“字”字符字符串最后一个字符为非“字”字符两个单词字符之间两个非单词字符之间空字符串例如，/\\B../匹配&quot;noonday&quot;中的&#39;oo&#39;, 而/y\\B../匹配&quot;possibly yesterday&quot;中的’yes‘ | | <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-control" target="_blank" rel="noreferrer"><code>\\cX</code></a> | 当 X 是处于 A 到 Z 之间的字符的时候，匹配字符串中的一个控制符。例如，<code>/\\cM/</code> 匹配字符串中的 control-M (U+000D)。 | | <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-digit" target="_blank" rel="noreferrer"><code>\\d</code></a> | 匹配一个数字<code>。\`\`等价于[0-9]</code>。例如， <code>/\\d/</code> 或者 <code>/[0-9]/</code> 匹配&quot;B2 is the suite number.&quot;中的&#39;2&#39;。 | | <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-non-digit" target="_blank" rel="noreferrer"><code>\\D</code></a> | 匹配一个非数字字符<code>。\`\`等价于[^0-9]</code>。例如， <code>/\\D/</code> 或者 <code>/[^0-9]/</code> 匹配&quot;B2 is the suite number.&quot;中的&#39;B&#39; 。 | | <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-form-feed" target="_blank" rel="noreferrer"><code>\\f</code></a> | 匹配一个换页符 (U+000C)。 | | <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-line-feed" target="_blank" rel="noreferrer"><code>\\n</code></a> | 匹配一个换行符 (U+000A)。 | | <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-carriage-return" target="_blank" rel="noreferrer"><code>\\r</code></a> | 匹配一个回车符 (U+000D)。 | | <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-white-space" target="_blank" rel="noreferrer"><code>\\s</code></a> | 匹配一个空白字符，包括空格、制表符、换页符和换行符。等价于[ \\f\\n\\r\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]。例如, <code>/\\s\\w*/</code> 匹配&quot;foo bar.&quot;中的&#39; bar&#39;。经测试，\\s 不匹配&quot;<a href="https://unicode-table.com/cn/180E/" target="_blank" rel="noreferrer">\\u180e</a>&quot;，在当前版本 Chrome(v80.0.3987.122)和 Firefox(76.0.1)控制台输入/\\s/.test(&quot;\\u180e&quot;)均返回 false。 | | <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-non-white-space" target="_blank" rel="noreferrer"><code>\\S</code></a> | 匹配一个非空白字符。等价于 <code>[^ </code>\\f\\n\\r\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff<code>]</code>。例如，<code>/\\S\\w*/</code> 匹配&quot;foo bar.&quot;中的&#39;foo&#39;。 | | <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-tab" target="_blank" rel="noreferrer"><code>\\t</code></a> | 匹配一个水平制表符 (U+0009)。 | | <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-vertical-tab" target="_blank" rel="noreferrer"><code>\\v</code></a> | 匹配一个垂直制表符 (U+000B)。 | | <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-word" target="_blank" rel="noreferrer"><code>\\w</code></a> | 匹配一个单字字符（字母、数字或者下划线）。等价于 <code>[A-Za-z0-9_]</code>。例如, <code>/\\w/</code> 匹配 &quot;apple,&quot; 中的 &#39;a&#39;，&quot;$5.28,&quot;中的 &#39;5&#39; 和 &quot;3D.&quot; 中的 &#39;3&#39;。 | | <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-non-word" target="_blank" rel="noreferrer"><code>\\W</code></a> | 匹配一个非单字字符。等价于 <code>[^A-Za-z0-9_]</code>。例如, <code>/\\W/</code> 或者 <code>/[^A-Za-z0-9_]/</code> 匹配 &quot;50%.&quot; 中的 &#39;%&#39;。 | | <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-backreference" target="_blank" rel="noreferrer"><code>\\n</code></a> | 在正则表达式中，它返回最后的第 n 个子捕获匹配的子字符串(捕获的数目以左括号计数)。比如 <code>/apple(,)\\sorange\\1/</code> 匹配&quot;apple, orange, cherry, peach.&quot;中的&#39;apple, orange,&#39; 。 | | <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-null" target="_blank" rel="noreferrer"><code>\\0</code></a> | 匹配 NULL（U+0000）字符， 不要在这后面跟其它小数，因为 <code>\\0&lt;digits&gt;</code> 是一个八进制转义序列。 | | <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-hex-escape" target="_blank" rel="noreferrer"><code>\\xhh</code></a> | 匹配一个两位十六进制数（\\x00-\\xFF）表示的字符。 | | <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-unicode-escape" target="_blank" rel="noreferrer"><code>\\uhhhh</code></a> | 匹配一个四位十六进制数表示的 UTF-16 代码单元。 | | <code>\\u{hhhh}或\\u{hhhhh}</code> | （仅当设置了 u 标志时）匹配一个十六进制数表示的 Unicode 字符。 |</p><h3 id="_3、转义字符" tabindex="-1">3、转义字符 <a class="header-anchor" href="#_3、转义字符" aria-label="Permalink to &quot;3、转义字符&quot;">​</a></h3><h3 id="_4、插入语" tabindex="-1">4、插入语 <a class="header-anchor" href="#_4、插入语" aria-label="Permalink to &quot;4、插入语&quot;">​</a></h3><p>任何正则表达式的插入语都会使这部分匹配的副字符串被记忆。一旦被记忆，这个副字符串就可以被调用于其它用途，如同 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#%E4%BD%BF%E7%94%A8%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D" target="_blank" rel="noreferrer">使用括号的子字符串匹配</a>之中所述。</p><h3 id="_5、使用" tabindex="-1">5、使用 <a class="header-anchor" href="#_5、使用" aria-label="Permalink to &quot;5、使用&quot;">​</a></h3><table><thead><tr><th style="text-align:left;">方法</th><th style="text-align:left;">描述</th></tr></thead><tbody><tr><td style="text-align:left;"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec" target="_blank" rel="noreferrer"><code>exec</code></a></td><td style="text-align:left;">一个在字符串中执行查找匹配的 RegExp 方法，它返回一个数组（未匹配到则返回 null）。</td></tr><tr><td style="text-align:left;"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test" target="_blank" rel="noreferrer"><code>test</code></a></td><td style="text-align:left;">一个在字符串中测试是否匹配的 RegExp 方法，它返回 true 或 false。</td></tr><tr><td style="text-align:left;"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/match" target="_blank" rel="noreferrer"><code>match</code></a></td><td style="text-align:left;">一个在字符串中执行查找匹配的 String 方法，它返回一个数组，在未匹配到时会返回 null。</td></tr><tr><td style="text-align:left;"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/matchAll" target="_blank" rel="noreferrer"><code>matchAll</code></a></td><td style="text-align:left;">一个在字符串中执行查找所有匹配的 String 方法，它返回一个迭代器（iterator）。</td></tr><tr><td style="text-align:left;"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/search" target="_blank" rel="noreferrer"><code>search</code></a></td><td style="text-align:left;">一个在字符串中测试匹配的 String 方法，它返回匹配到的位置索引，或者在失败时返回-1。</td></tr><tr><td style="text-align:left;"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace" target="_blank" rel="noreferrer"><code>replace</code></a></td><td style="text-align:left;">一个在字符串中执行查找匹配的 String 方法，并且使用替换字符串替换掉匹配到的子字符串。</td></tr><tr><td style="text-align:left;"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/split" target="_blank" rel="noreferrer"><code>split</code></a></td><td style="text-align:left;">一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的 <code>String</code> 方法。</td></tr></tbody></table><p>当你想要知道在一个字符串中的一个匹配是否被找到，你可以使用 test 或 search 方法；想得到更多的信息（但是比较慢）则可以使用 exec 或 match 方法。如果你使用 exec 或 match 方法并且匹配成功了，那么这些方法将返回一个数组并且更新相关的正则表达式对象的属性和预定义的正则表达式对象（详见下）。如果匹配失败，那么 exec 方法返回 null（也就是 false）</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> myArray </span><span style="color:#F97583;">=</span><span style="color:#DBEDFF;"> </span><span style="color:#9ECBFF;">/</span><span style="color:#DBEDFF;">d(b</span><span style="color:#F97583;">+</span><span style="color:#DBEDFF;">)d</span><span style="color:#9ECBFF;">/</span><span style="color:#F97583;">g</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">exec</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;cdbbdbsbz&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#6A737D;">// 和 &quot;cdbbdbsbz&quot;.match(/d(b+)d/g); 相似。</span></span>
<span class="line"><span style="color:#6A737D;">// 但是 &quot;cdbbdbsbz&quot;.match(/d(b+)d/g) 输出数组 [ &quot;dbbd&quot; ]，</span></span>
<span class="line"><span style="color:#6A737D;">// 而 /d(b+)d/g.exec(&#39;cdbbdbsbz&#39;) 输出数组 [ &quot;dbbd&quot;, &quot;bb&quot;, index: 1, input: &quot;cdbbdbsbz&quot; ].</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">var</span><span style="color:#24292E;"> myArray </span><span style="color:#D73A49;">=</span><span style="color:#032F62;"> /d(b</span><span style="color:#D73A49;">+</span><span style="color:#032F62;">)d/</span><span style="color:#D73A49;">g</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">exec</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;cdbbdbsbz&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#6A737D;">// 和 &quot;cdbbdbsbz&quot;.match(/d(b+)d/g); 相似。</span></span>
<span class="line"><span style="color:#6A737D;">// 但是 &quot;cdbbdbsbz&quot;.match(/d(b+)d/g) 输出数组 [ &quot;dbbd&quot; ]，</span></span>
<span class="line"><span style="color:#6A737D;">// 而 /d(b+)d/g.exec(&#39;cdbbdbsbz&#39;) 输出数组 [ &quot;dbbd&quot;, &quot;bb&quot;, index: 1, input: &quot;cdbbdbsbz&quot; ].</span></span></code></pre></div><h4 id="正则表达式执行后的返回信息" tabindex="-1">正则表达式执行后的返回信息 <a class="header-anchor" href="#正则表达式执行后的返回信息" aria-label="Permalink to &quot;正则表达式执行后的返回信息&quot;">​</a></h4><table><thead><tr><th style="text-align:left;">对象</th><th></th><th style="text-align:left;">属性或索引</th><th style="text-align:left;">描述</th><th style="text-align:left;">在例子中对应的值</th></tr></thead><tbody><tr><td style="text-align:left;"><code>myArray</code></td><td></td><td style="text-align:left;"></td><td style="text-align:left;">匹配到的字符串和所有被记住的子字符串。</td><td style="text-align:left;"><code>[&quot;dbbd&quot;, &quot;bb&quot;]</code></td></tr><tr><td style="text-align:left;"></td><td><code>index</code></td><td style="text-align:left;">在输入的字符串中匹配到的以 0 开始的索引值。</td><td style="text-align:left;"><code>1</code></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;"></td><td><code>input</code></td><td style="text-align:left;">初始字符串。</td><td style="text-align:left;"><code>&quot;cdbbdbsbz&quot;</code></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;"></td><td><code>[0]</code></td><td style="text-align:left;">最近一个匹配到的字符串。</td><td style="text-align:left;"><code>&quot;dbbd&quot;</code></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;"><code>myRe</code></td><td></td><td style="text-align:left;"><code>lastIndex</code></td><td style="text-align:left;">开始下一个匹配的起始索引值。（这个属性只有在使用 g 参数时可用在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#.E9.80.9A.E8.BF.87.E5.8F.82.E6.95.B0.E8.BF.9B.E8.A1.8C.E9.AB.98.E7.BA.A7.E6.90.9C.E7.B4.A2" target="_blank" rel="noreferrer">通过参数进行高级搜索</a> 一节有详细的描述.)</td><td style="text-align:left;"><code>5</code></td></tr><tr><td style="text-align:left;"><code>source</code></td><td></td><td style="text-align:left;">模式字面文本。在正则表达式创建时更新，不执行。</td><td style="text-align:left;"><code>&quot;d(b+)d&quot;</code></td><td style="text-align:left;"></td></tr></tbody></table><h4 id="使用括号的子字符串匹配" tabindex="-1">使用括号的子字符串匹配 <a class="header-anchor" href="#使用括号的子字符串匹配" aria-label="Permalink to &quot;使用括号的子字符串匹配&quot;">​</a></h4><p>一个正则表达式模式使用括号，将导致相应的子匹配被记住。例如，/a(b)c /可以匹配字符串“abc”，并且记得“b”。回调这些括号中匹配的子串，使用数组元素[1],……[n]。</p><p>使用括号匹配的子字符串的数量是无限的。返回的数组中保存所有被发现的子匹配。下面的例子说明了如何使用括号的子字符串匹配。</p><p>下面的脚本使用 replace()方法来转换字符串中的单词。在匹配到的替换文本中，脚本使用替代的$ 1,$ 2 表示第一个和第二个括号的子字符串匹配。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">var re = /(\\w+)\\s(\\w+)/;</span></span>
<span class="line"><span style="color:#e1e4e8;">var str = &quot;John Smith&quot;;</span></span>
<span class="line"><span style="color:#e1e4e8;">var newstr = str.replace(re, &quot;$2, $1&quot;);</span></span>
<span class="line"><span style="color:#e1e4e8;">console.log(newstr);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">var re = /(\\w+)\\s(\\w+)/;</span></span>
<span class="line"><span style="color:#24292e;">var str = &quot;John Smith&quot;;</span></span>
<span class="line"><span style="color:#24292e;">var newstr = str.replace(re, &quot;$2, $1&quot;);</span></span>
<span class="line"><span style="color:#24292e;">console.log(newstr);</span></span></code></pre></div><p>这个表达式输出 &quot;Smith, John&quot;。</p><h4 id="通过标志进行高级搜索" tabindex="-1">通过标志进行高级搜索 <a class="header-anchor" href="#通过标志进行高级搜索" aria-label="Permalink to &quot;通过标志进行高级搜索&quot;">​</a></h4><p>正则表达式有六个可选参数 (<code>flags</code>) 允许全局和不分大小写搜索等。这些参数既可以单独使用也能以任意顺序一起使用, 并且被包含在正则表达式实例中。</p><table><thead><tr><th style="text-align:left;">标志</th><th style="text-align:left;">描述</th></tr></thead><tbody><tr><td style="text-align:left;"><code>g</code></td><td style="text-align:left;">全局搜索。</td></tr><tr><td style="text-align:left;"><code>i</code></td><td style="text-align:left;">不区分大小写搜索。</td></tr><tr><td style="text-align:left;"><code>m</code></td><td style="text-align:left;">多行搜索。</td></tr><tr><td style="text-align:left;"><code>s</code></td><td style="text-align:left;">允许 <code>.</code> 匹配换行符。</td></tr><tr><td style="text-align:left;"><code>u</code></td><td style="text-align:left;">使用 unicode 码的模式进行匹配。</td></tr><tr><td style="text-align:left;"><code>y</code></td><td style="text-align:left;">执行“粘性(<code>sticky</code>)”搜索,匹配从目标字符串的当前位置开始。</td></tr></tbody></table><p>为了在正则表达式中包含标志，请使用以下语法：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">var re = /pattern/flags;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">var re = /pattern/flags;</span></span></code></pre></div><p>或者</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">var re = new RegExp(&quot;pattern&quot;, &quot;flags&quot;);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">var re = new RegExp(&quot;pattern&quot;, &quot;flags&quot;);</span></span></code></pre></div><p>值得注意的是，标志是一个正则表达式的一部分，它们在接下来的时间将不能添加或删除。</p><p>例如，re = /\\w+\\s/g 将创建一个查找一个或多个字符后有一个空格的正则表达式，或者组合起来像此要求的字符串。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">var re = /\\w+\\s/g;</span></span>
<span class="line"><span style="color:#e1e4e8;">var str = &quot;fee fi fo fum&quot;;</span></span>
<span class="line"><span style="color:#e1e4e8;">var myArray = str.match(re);</span></span>
<span class="line"><span style="color:#e1e4e8;">console.log(myArray);</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">// [&quot;fee &quot;, &quot;fi &quot;, &quot;fo &quot;]</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">var re = /\\w+\\s/g;</span></span>
<span class="line"><span style="color:#24292e;">var str = &quot;fee fi fo fum&quot;;</span></span>
<span class="line"><span style="color:#24292e;">var myArray = str.match(re);</span></span>
<span class="line"><span style="color:#24292e;">console.log(myArray);</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">// [&quot;fee &quot;, &quot;fi &quot;, &quot;fo &quot;]</span></span></code></pre></div><p>这段代码将输出 [&quot;fee &quot;, &quot;fi &quot;, &quot;fo &quot;]。在这个例子中，你可以将：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">var re = /\\w+\\s/g;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">var re = /\\w+\\s/g;</span></span></code></pre></div><p>替换成：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">var re = new RegExp(&quot;\\\\w+\\\\s&quot;, &quot;g&quot;);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">var re = new RegExp(&quot;\\\\w+\\\\s&quot;, &quot;g&quot;);</span></span></code></pre></div><p>并且能获取到相同的结果。</p><p>使用<code>.exec()</code>方法时，与&#39;<code>g</code>&#39;标志关联的行为是不同的。 （“class”和“argument”的作用相反：在<code>.match()</code>的情况下，字符串类（或数据类型）拥有该方法，而正则表达式只是一个参数，而在<code>.exec()</code>的情况下，它是拥有该方法的正则表达式，其中字符串是参数。对比*<code>str.match(re)</code><em>与</em><code>re.exec(str)</code>* ), &#39;<code>g</code>&#39;标志与<code>.exec()</code>方法一起使用获得迭代进展。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">var xArray; while(xArray = re.exec(str)) console.log(xArray);</span></span>
<span class="line"><span style="color:#e1e4e8;">// produces:</span></span>
<span class="line"><span style="color:#e1e4e8;">// [&quot;fee &quot;, index: 0, input: &quot;fee fi fo fum&quot;]</span></span>
<span class="line"><span style="color:#e1e4e8;">// [&quot;fi &quot;, index: 4, input: &quot;fee fi fo fum&quot;]</span></span>
<span class="line"><span style="color:#e1e4e8;">// [&quot;fo &quot;, index: 7, input: &quot;fee fi fo fum&quot;]</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">var xArray; while(xArray = re.exec(str)) console.log(xArray);</span></span>
<span class="line"><span style="color:#24292e;">// produces:</span></span>
<span class="line"><span style="color:#24292e;">// [&quot;fee &quot;, index: 0, input: &quot;fee fi fo fum&quot;]</span></span>
<span class="line"><span style="color:#24292e;">// [&quot;fi &quot;, index: 4, input: &quot;fee fi fo fum&quot;]</span></span>
<span class="line"><span style="color:#24292e;">// [&quot;fo &quot;, index: 7, input: &quot;fee fi fo fum&quot;]</span></span></code></pre></div><p>m 标志用于指定多行输入字符串应该被视为多个行。如果使用 m 标志，^和$匹配的开始或结束输入字符串中的每一行，而不是整个字符串的开始或结束。</p>`,52),l=[s];function c(n,d,p,i,u,h){return t(),a("div",null,l)}const f=e(r,[["render",c]]);export{b as __pageData,f as default};
