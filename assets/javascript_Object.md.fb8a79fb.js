import{_ as e,c as t,o as a,V as r}from"./chunks/framework.25f281e8.js";const u=JSON.parse('{"title":"Object","description":"","frontmatter":{},"headers":[],"relativePath":"javascript/Object.md","filePath":"javascript/Object.md"}'),o={name:"javascript/Object.md"},p=r('<h1 id="object" tabindex="-1">Object <a class="header-anchor" href="#object" aria-label="Permalink to &quot;Object&quot;">​</a></h1><p>Object.defineProperty()</p><p><strong>要注意有一个小小的例外：即便属性是 configurable:false，我们还是可以把 writable 的状态由 true 改为 false，但是无法由 false 改为 true。</strong></p><p>configurable:false 会禁止删除这个属性</p><p>writable:false,configurable:false 可以创建一个常量属性。</p><p>如果你想禁止一个对象添加新属性并且保留已有属性，可以使用 Object.preventExtensions(obj)</p><p>Object.seal(..)会创建一个“密封”的对象，这个方法实际上会在一个现有对象上调用 Object.preventExtensions(..)并把所有现有属性标记为 configurable:false。（不能添加新属性，不能重新配置或删除属性，<strong>但可以修改属性值</strong>）</p><p>Object.freeze(..)会创建一个冻结对象，这个方法实际上会在一个现有对象上调用 Object.seal(..)并把所有“数据访问”属性标记为 writable:false，这样就无法修改它们的值。（浅层）</p><p>obj.hasOwnProperty(&quot;ab&quot;)判断对象是否存在这个属性。（只检查当前对像）</p><p>in 操作符 （会检查原型链，无论是否可枚举）</p><p>注意：看起来 in 操作符可以检查容器内是否有某个值，但是它实际上检查的是某个属性名是否存在。对于数组来说这个区别非常重要，4 in [2, 4, 6]的结果并不是你期待的 True，因为[2, 4, 6]这个数组中包含的属性名是 0、1、2，没有 4。</p><p>obj.propertyIsEnumerable(&quot;ab&quot;) 会检查给定的属性名是否直接存在于对象中（而不是在原型链上）并且满足 enumerable:true。</p><p>Object.keys(..)会返回一个数组，包含所有可枚举属性</p><p>Object.getOwnPropertyNames(..)会返回一个数组，包含所有属性，无论它们是否可枚举。</p><p>对象不可以使用 for...of 遍历，但是可以自定义迭代器实现</p>',15),s=[p];function c(n,b,i,l,_,f){return a(),t("div",null,s)}const O=e(o,[["render",c]]);export{u as __pageData,O as default};
