import{_ as e,c as a,o as l,Q as i}from"./chunks/framework.00751356.js";const T=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"basic/network/network-interview.md","filePath":"basic/network/network-interview.md"}'),t={name:"basic/network/network-interview.md"},o=i('<h2 id="tcp-和-udp" tabindex="-1">TCP 和 UDP <a class="header-anchor" href="#tcp-和-udp" aria-label="Permalink to &quot;TCP 和 UDP&quot;">​</a></h2><h3 id="三次握手" tabindex="-1">三次握手 <a class="header-anchor" href="#三次握手" aria-label="Permalink to &quot;三次握手&quot;">​</a></h3><p>最开始的时候客户端和服务器都是处于 CLOSED 状态。主动打开连接的为客户端，被动打开连接的是服务器。</p><h4 id="三次握手过程" tabindex="-1">三次握手过程 <a class="header-anchor" href="#三次握手过程" aria-label="Permalink to &quot;三次握手过程&quot;">​</a></h4><h3 id="四次挥手" tabindex="-1">四次挥手 <a class="header-anchor" href="#四次挥手" aria-label="Permalink to &quot;四次挥手&quot;">​</a></h3><p>数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于 ESTABLISHED 状态，然后客户端主动关闭，服务器被动关闭。</p><h4 id="四次挥手过程" tabindex="-1">四次挥手过程 <a class="header-anchor" href="#四次挥手过程" aria-label="Permalink to &quot;四次挥手过程&quot;">​</a></h4><h3 id="udp" tabindex="-1">UDP <a class="header-anchor" href="#udp" aria-label="Permalink to &quot;UDP&quot;">​</a></h3><h4 id="udp-特点" tabindex="-1">UDP 特点 <a class="header-anchor" href="#udp-特点" aria-label="Permalink to &quot;UDP 特点&quot;">​</a></h4><ul><li>无连接</li><li>面向报文</li><li>尽最大努力交付</li><li>无拥塞控制</li><li>支持一对一、一对多、多对一、多对多通信</li><li>首部只有 8 个字节</li></ul><h2 id="dns" tabindex="-1">DNS <a class="header-anchor" href="#dns" aria-label="Permalink to &quot;DNS&quot;">​</a></h2><h2 id="简单请求和复杂请求" tabindex="-1">简单请求和复杂请求 <a class="header-anchor" href="#简单请求和复杂请求" aria-label="Permalink to &quot;简单请求和复杂请求&quot;">​</a></h2><p>CORS 即 Cross Origin Resource Sharing（跨来源资源共享），通俗说就是我们所熟知的跨域请求。众所周知，在以前，跨域可以采用代理、JSONP 等方式，而在 Modern 浏览器面前，这些终将成为过去式，因为有了 CORS。</p><p>CORS 在最初接触的时候只大概了解到，通过服务器端设置<code>Access-Control-Allow-Origin</code> 响应头，即可使指定来源像访问同源接口一样访问跨域接口，最近在使用 CORS 的时候，由于需要传输自定义 Header 信息，发现原来 CORS 的规范定义远不止这些。</p><p>CORS 可以分成两种：</p><p>1、<strong>简单请求</strong> 2、<strong>复杂请求</strong></p><h4 id="_1-简单请求" tabindex="-1">1.简单请求： <a class="header-anchor" href="#_1-简单请求" aria-label="Permalink to &quot;1.简单请求：&quot;">​</a></h4><p><strong>HTTP 方法是下列之一</strong></p><ul><li>HEAD</li><li>GET</li><li>POST</li></ul><p><strong>HTTP 头信息不超出以下几种字段</strong></p><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type，但仅能是下列之一</li><li>application/x-www-form-urlencoded</li><li>multipart/form-data</li><li>text/plain</li></ul><p>任何一个不满足上述要求的请求，即被认为是复杂请求。一个复杂请求不仅有包含通信内容的请求，同时也包含预请求（preflight request）。</p><p>简单请求的发送从代码上来看和普通的 XHR 没太大区别，但是 HTTP 头当中要求总是包含一个域（Origin）的信息。该域包含协议名、地址以及一个可选的端口。不过这一项实际上由浏览器代为发送，并不是开发者代码可以触及到的。</p><p><strong>简单请求的部分响应头及解释如下：</strong></p><ul><li>Access-Control-Allow-Origin（必含）- 不可省略，否则请求按失败处理。该项控制数据的可见范围，如果希望数据对任何人都可见，可以填写&quot;*&quot;。</li><li>Access-Control-Allow-Credentials（可选） – 该项标志着请求当中是否包含 cookies 信息，只有一个可选值：true（必为小写）。如果不包含 cookies，请略去该项，而不是填写 false。这一项与 XmlHttpRequest2 对象当中的 withCredentials 属性应保持一致，即 withCredentials 为 true 时该项也为 true；withCredentials 为 false 时，省略该项不写。反之则导致请求失败。</li><li>Access-Control-Expose-Headers（可选） – 该项确定 XmlHttpRequest2 对象当中 getResponseHeader() 方法所能获得的额外信息。通常情况下，getResponseHeader()方法只能获得如下的信息：</li><li>Cache-Control</li><li>Content-Language</li><li>Content-Type</li><li>Expires</li><li>Last-Modified</li><li>Pragma</li><li>当你需要访问额外的信息时，就需要在这一项当中填写并以逗号进行分隔</li></ul><p>如果仅仅是简单请求，那么即便不用 CORS 也没有什么大不了，但 CORS 的复杂请求就令 CORS 显得更加有用了。简单来说，任何不满足上述简单请求要求的请求，都属于复杂请求。比如说你需要发送 PUT、DELETE 等 HTTP 动作，或者发送 Content-Type: application/json 的内容。</p><h4 id="_2-复杂请求" tabindex="-1">2.复杂请求 <a class="header-anchor" href="#_2-复杂请求" aria-label="Permalink to &quot;2.复杂请求&quot;">​</a></h4><p>复杂请求表面上看起来和简单请求使用上差不多，但实际上浏览器发送了不止一个请求。其中最先发送的是一种&quot;预请求&quot; ，此时作为服务端，也需要返回&quot;预回应&quot;作为响应。预请求实际上是对服务端的一种权限请求，只有当预请求成功返回，实际请求才开始执行。</p><p>预请求以 OPTIONS 形式发送，当中同样包含域，并且还包含了两项 CORS 特有的内容：</p><ul><li>Access-Control-Request-Method – 该项内容是实际请求的种类，可以是 GET、POST 之类的简单请求，也可以是 PUT、DELETE 等等。</li><li>Access-Control-Request-Headers – 该项是一个以逗号分隔的列表，当中是复杂请求所使用的头部。</li></ul><p>显而易见，这个预请求实际上就是在为之后的实际请求发送一个权限请求，在预回应返回的内容当中，服务端应当对这两项进行回复，以让浏览器确定请求是否能够成功完成。</p><p><strong>复杂请求的部分响应头及解释如下：</strong></p><ul><li>Access-Control-Allow-Origin（必含） – 和简单请求一样的，必须包含一个域。</li><li>Access-Control-Allow-Methods（必含） – 这是对预请求当中 Access-Control-Request-Method 的回复，这一回复将是一个以逗号分隔的列表。尽管客户端或许只请求某一方法，但服务端仍然可以返回所有允许的方法，以便客户端将其缓存。</li><li>Access-Control-Allow-Headers（当预请求中包含 Access-Control-Request-Headers 时必须包含） – 这是对预请求当中 Access-Control-Request-Headers 的回复，和上面一样是以逗号分隔的列表，可以返回所有支持的头部。这里在实际使用中有遇到，所有支持的头部一时可能不能完全写出来，而又不想在这一层做过多的判断，没关系，事实上通过 request 的 header 可以直接取到 Access-Control-Request-Headers，直接把对应的 value 设置到 Access-Control-Allow-Headers 即可。</li><li>Access-Control-Allow-Credentials（可选） – 和简单请求当中作用相同。</li><li>Access-Control-Max-Age（可选） – 以秒为单位的缓存时间。预请求的的发送并非免费午餐，允许时应当尽可能缓存。</li></ul><p>一旦预回应如期而至，所请求的权限也都已满足，则实际请求开始发送。</p><p>通过 caniuse.com 得知，目前大部分 Modern 浏览器已经支持完整的 CORS，但 IE 直到 IE11 才完美支持，所以对于 PC 网站，还是建议采用其他解决方案，如果仅仅是移动端网站，大可放心使用。</p><h2 id="cookie" tabindex="-1">Cookie <a class="header-anchor" href="#cookie" aria-label="Permalink to &quot;Cookie&quot;">​</a></h2><h3 id="set-cookie-字段" tabindex="-1">set-cookie 字段 <a class="header-anchor" href="#set-cookie-字段" aria-label="Permalink to &quot;set-cookie 字段&quot;">​</a></h3><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>NAME=VALUE</td><td>赋予 cookie 的名称和值</td></tr><tr><td>expires=DATE</td><td>cookie 的有效期，<strong>不明确指定默认为浏览器关闭为止</strong></td></tr><tr><td>path=PATH</td><td>将服务器上的文件目录作为 cookie 的适用对象，不指定默认为文档所在的文件目录</td></tr><tr><td>domain=域名</td><td>作为 cookie 适用对象的域名，不指定默认为创建 cookie 的服务器的域名</td></tr><tr><td>Secure</td><td>仅在 https 安全通信时才会发送 cookie</td></tr><tr><td>HttpOnly</td><td>加以限制，使 cookie 不能够被 javascript 脚本访问</td></tr></tbody></table><ul><li>一旦 cookie 从服务器发送到客户端，服务端不存在可以显式删除 cookie 的方法，但可以通过覆盖已过期的 cookie，实现对客户端 cookie 的实质性删除的操作。</li><li>domain 指定的域名可做到与结尾匹配一致。比如，当指定 example.com 后，除了 example.com 以外，www.example.com/www2.example.com都可以发送cookie。因此不指定显得更安全。</li></ul><h2 id="get-和-post" tabindex="-1">GET 和 POST <a class="header-anchor" href="#get-和-post" aria-label="Permalink to &quot;GET 和 POST&quot;">​</a></h2><p>(1) GET 请求在浏览器回退和刷新时是无害的，而 POST 请求会告知用户数据会被重新提交；</p><p>(2) GET 请求可以收藏为书签，POST 请求不可以收藏为书签；</p><p>(3) GET 请求可以被缓存，POST 请求不可以被缓存，除非在响应头中包含合适的 Cache-Control/Expires 字段，但是不建议缓存 POST 请求，其不满足幂等性，每次调用都会对服务器资源造成影响；</p><p>(4) GET 请求一般不具有请求体，因此只能进行 url 编码，而 POST 请求支持多种编码方式。</p><p>(5) GET 请求的参数可以被保留在浏览器的历史中，POST 请求不会被保留；</p><p>(6) GET 请求因为是向 URL 添加数据，不同的浏览器厂商，代理服务器，web 服务器都可能会有自己的长度限制，而 POST 请求无长度限制；</p><p>(7) GET 请求只允许 ASCII 字符，POST 请求无限制，支持二进制数据；</p><p>(8) GET 请求的安全性较差，数据被暴露在浏览器的 URL 中，所以不能用来传递敏感信息，POST 请求的安全性较好，数据不会暴露在 URL 中；</p><p>(9) GET 请求具有幂等性(多次请求不会对资源造成影响)，POST 请求不幂等；</p><p>(10) GET 请求一般不具有请求体，请求中一般不包含 100-continue 协议，所以只会发一次请求，而 POST 请求在发送数据到服务端之前允许双方&quot;握手&quot;，客户端先发送 Expect: 100-continue 消息，询问服务端是否愿意接收数据，接收到服务端正确的 100-continue 应答后才会将请求体发送给服务端，服务端再响应 200 返回数据。</p><h3 id="icmp" tabindex="-1">ICMP <a class="header-anchor" href="#icmp" aria-label="Permalink to &quot;ICMP&quot;">​</a></h3><p>OSI（开放式通信系统互联参考模型）</p><ul><li>物理层：0、1 比特流</li><li>数据链路层：数据帧传输</li><li>网络层：数据传输到目标地址</li><li>传输层：可靠传输</li><li>会话层：建立和断开通信连接</li><li>表示层：数据格式转换</li><li>应用层：提供服务</li></ul><h2 id="_3-问-http-缓存" tabindex="-1">3）问：HTTP 缓存 <a class="header-anchor" href="#_3-问-http-缓存" aria-label="Permalink to &quot;3）问：HTTP 缓存&quot;">​</a></h2><p>HTTP 缓存又分为强缓存和协商缓存：</p><ul><li><p>首先通过 Cache-Control 验证强缓存是否可用，如果强缓存可用，那么直接读取缓存</p></li><li><p>如果不可以，那么进入协商缓存阶段，发起 HTTP 请求，服务器通过请求头中是否带上 If-Modified-Since 和 If-None-Match 这些条件请求字段检查资源是否更新：</p></li><li><ul><li>若资源更新，那么返回资源和 200 状态码</li><li>如果资源未更新，那么告诉浏览器直接使用缓存获取资源</li></ul></li></ul><h2 id="_5-问-http-常用的状态码及使用场景" tabindex="-1">5）问：HTTP 常用的状态码及使用场景？ <a class="header-anchor" href="#_5-问-http-常用的状态码及使用场景" aria-label="Permalink to &quot;5）问：HTTP 常用的状态码及使用场景？&quot;">​</a></h2><ul><li>1xx：表示目前是协议的中间状态，还需要后续请求</li><li>2xx：表示请求成功</li><li>3xx：表示重定向状态，需要重新请求</li><li>4xx：表示请求报文错误</li><li>5xx：服务器端错误</li></ul><p>常用状态码：</p><ul><li>101 切换请求协议，从 HTTP 切换到 WebSocket</li><li>200 请求成功，有响应体</li><li>301 永久重定向：会缓存</li><li>302 临时重定向：不会缓存</li><li>304 协商缓存命中</li><li>403 服务器禁止访问</li><li>404 资源未找到</li><li>400 请求错误</li><li>500 服务器端错误</li><li>503 服务器繁忙</li></ul><h2 id="你知道-302-状态码是什么嘛-你平时浏览网页的过程中遇到过哪些-302-的场景" tabindex="-1">你知道 302 状态码是什么嘛？你平时浏览网页的过程中遇到过哪些 302 的场景？ <a class="header-anchor" href="#你知道-302-状态码是什么嘛-你平时浏览网页的过程中遇到过哪些-302-的场景" aria-label="Permalink to &quot;你知道 302 状态码是什么嘛？你平时浏览网页的过程中遇到过哪些 302 的场景？&quot;">​</a></h2><p>而 302 表示临时重定向，这个资源只是暂时不能被访问了，但是之后过一段时间还是可以继续访问，一般是访问某个网站的资源需要权限时，会需要用户去登录，跳转到登录页面之后登录之后，还可以继续访问。</p><p>301 类似，都会跳转到一个新的网站，但是 301 代表访问的地址的资源被永久移除了，以后都不应该访问这个地址，搜索引擎抓取的时候也会用新的地址替换这个老的。可以在返回的响应的 location 首部去获取到返回的地址。301 的场景如下：</p><ul><li>比如从 <a href="http://baidu.com" target="_blank" rel="noreferrer">http://baidu.com</a>，跳转到 <a href="https://baidu.com" target="_blank" rel="noreferrer">https://baidu.com</a></li><li>域名换了</li></ul><h2 id="_2-问-http-常用的请求方式-区别和用途" tabindex="-1">2）问：HTTP 常用的请求方式，区别和用途？ <a class="header-anchor" href="#_2-问-http-常用的请求方式-区别和用途" aria-label="Permalink to &quot;2）问：HTTP 常用的请求方式，区别和用途？&quot;">​</a></h2><p>http/1.1 规定如下请求方法：</p><ul><li>GET：通用获取数据</li><li>HEAD：获取资源的元信息</li><li>POST：提交数据</li><li>PUT：修改数据</li><li>DELETE：删除数据</li><li>CONNECT：建立连接隧道，用于代理服务器</li><li>OPTIONS：列出可对资源实行的请求方法，常用于跨域</li><li>TRACE：追踪请求-响应的传输路径</li></ul><h2 id="问-你对计算机网络的认识怎么样" tabindex="-1">（）问：你对计算机网络的认识怎么样 <a class="header-anchor" href="#问-你对计算机网络的认识怎么样" aria-label="Permalink to &quot;（）问：你对计算机网络的认识怎么样&quot;">​</a></h2><blockquote><p>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</p></blockquote><h2 id="_3-问-https-是什么-具体流程" tabindex="-1">3）问：HTTPS 是什么？具体流程 <a class="header-anchor" href="#_3-问-https-是什么-具体流程" aria-label="Permalink to &quot;3）问：HTTPS 是什么？具体流程&quot;">​</a></h2><p>HTTPS 是在 HTTP 和 TCP 之间建立了一个安全层，HTTP 与 TCP 通信的时候，必须先进过一个安全层，对数据包进行加密，然后将加密后的数据包传送给 TCP，相应的 TCP 必须将数据包解密，才能传给上面的 HTTP。</p><p>浏览器传输一个 client_random 和加密方法列表，服务器收到后，传给浏览器一个 server_random、加密方法列表和数字证书（包含了公钥），然后浏览器对数字证书进行合法验证，如果验证通过，则生成一个 pre_random，然后用公钥加密传给服务器，服务器用 client_random、server_random 和 pre_random ，使用公钥加密生成 secret，然后之后的传输使用这个 secret 作为秘钥来进行数据的加解密。</p><h2 id="_4-问-三次握手和四次挥手" tabindex="-1">4）问：三次握手和四次挥手 <a class="header-anchor" href="#_4-问-三次握手和四次挥手" aria-label="Permalink to &quot;4）问：三次握手和四次挥手&quot;">​</a></h2><p>为什么要进行三次握手：为了确认对方的发送和接收能力。</p><h3 id="三次握手-1" tabindex="-1">三次握手 <a class="header-anchor" href="#三次握手-1" aria-label="Permalink to &quot;三次握手&quot;">​</a></h3><p>三次握手主要流程：</p><ul><li>一开始双方处于 CLOSED 状态，然后服务端开始监听某个端口进入 LISTEN 状态</li><li>然后客户端主动发起连接，发送 SYN，然后自己变为 SYN-SENT，seq = x</li><li>服务端收到之后，返回 SYN seq = y 和 ACK ack = x + 1（对于客户端发来的 SYN），自己变成 SYN-REVD</li><li>之后客户端再次发送 ACK seq = x + 1, ack = y + 1 给服务端，自己变成 EASTABLISHED 状态，服务端收到 ACK，也进入 ESTABLISHED</li></ul><blockquote><p>SYN 需要对端确认，所以 ACK 的序列化要加一，凡是需要对端确认的，一点要消耗 TCP 报文的序列化</p></blockquote><h3 id="四次挥手-1" tabindex="-1">四次挥手 <a class="header-anchor" href="#四次挥手-1" aria-label="Permalink to &quot;四次挥手&quot;">​</a></h3><ul><li>一开始都处于 ESTABLISH 状态，然后客户端发送 FIN 报文，带上 seq = p，状态变为 FIN-WAIT-1</li><li>服务端收到之后，发送 ACK 确认，ack = p + 1，然后进入 CLOSE-WAIT 状态</li><li>客户端收到之后进入 FIN-WAIT-2 状态</li><li>过了一会等数据处理完，再次发送 FIN、ACK，seq = q，ack = p + 1，进入 LAST-ACK 阶段</li><li>客户端收到 FIN 之后，客户端收到之后进入 TIME_WAIT（等待 2MSL），然后发送 ACK 给服务端 ack = 1 + 1</li><li>服务端收到之后进入 CLOSED 状态</li></ul><p>客户端这个时候还需要等待两次 MSL 之后，如果没有收到服务端的重发请求，就表明 ACK 成功到达，挥手结束，客户端变为 CLOSED 状态，否则进行 ACK 重发</p><h4 id="为什么需要等待-2msl-maximum-segement-lifetime" tabindex="-1">为什么需要等待 2MSL（Maximum Segement Lifetime）： <a class="header-anchor" href="#为什么需要等待-2msl-maximum-segement-lifetime" aria-label="Permalink to &quot;为什么需要等待 2MSL（Maximum Segement Lifetime）：&quot;">​</a></h4><p>因为如果不等待的话，如果服务端还有很多数据包要给客户端发，且此时客户端端口被新应用占据，那么就会接收到无用的数据包，造成数据包混乱，所以说最保险的方法就是等服务器发来的数据包都死翘翘了再启动新应用。</p><ul><li>1 个 MSL 保证四次挥手中主动关闭方最后的 ACK 报文能最终到达对端</li><li>1 个 MSL 保证对端没有收到 ACK 那么进行重传的 FIN 报文能够到达</li></ul><h4 id="为什么是四次而不是三次" tabindex="-1">为什么是四次而不是三次？ <a class="header-anchor" href="#为什么是四次而不是三次" aria-label="Permalink to &quot;为什么是四次而不是三次？&quot;">​</a></h4><p>** 如果是三次的话，那么服务端的 ACK 和 FIN 合成一个挥手，那么长时间的延迟可能让 TCP 一位 FIN 没有达到服务器端，然后让客户的不断的重发 FIN</p><h3 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-label="Permalink to &quot;参考资料&quot;">​</a></h3><ul><li><a href="https://zhuanlan.zhihu.com/p/86426969" target="_blank" rel="noreferrer">https://zhuanlan.zhihu.com/p/86426969</a></li></ul><h2 id="问-在交互过程中如果数据传送完了-还不想断开连接怎么办-怎么维持" tabindex="-1">问：在交互过程中如果数据传送完了，还不想断开连接怎么办，怎么维持？ <a class="header-anchor" href="#问-在交互过程中如果数据传送完了-还不想断开连接怎么办-怎么维持" aria-label="Permalink to &quot;问：在交互过程中如果数据传送完了，还不想断开连接怎么办，怎么维持？&quot;">​</a></h2><p>在 HTTP 中响应体的 Connection 字段指定为 keep-alive</p><h2 id="你对-tcp-滑动窗口有了解嘛" tabindex="-1">你对 TCP 滑动窗口有了解嘛？ <a class="header-anchor" href="#你对-tcp-滑动窗口有了解嘛" aria-label="Permalink to &quot;你对 TCP 滑动窗口有了解嘛？&quot;">​</a></h2><p>在 TCP 链接中，对于发送端和接收端而言，TCP 需要把发送的数据放到<strong>发送缓存区</strong>, 将接收的数据放到<strong>接收缓存区</strong>。而经常会存在发送端发送过多，而接收端无法消化的情况，所以就需要流量控制，就是在通过接收缓存区的大小，控制发送端的发送。如果对方的接收缓存区满了，就不能再继续发送了。而这种流量控制的过程就需要在发送端维护一个发送窗口，在接收端维持一个接收窗口。</p><p>TCP 滑动窗口分为两种: <strong>发送窗口</strong>和<strong>接收窗口</strong>。</p><h3 id="参考资料-1" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料-1" aria-label="Permalink to &quot;参考资料&quot;">​</a></h3><ul><li><a href="https://juejin.im/post/5e527c58e51d4526c654bf41#heading-38" target="_blank" rel="noreferrer">https://juejin.im/post/5e527c58e51d4526c654bf41#heading-38</a></li></ul><h2 id="问-websocket-与-ajax-的区别" tabindex="-1">问：WebSocket 与 Ajax 的区别 <a class="header-anchor" href="#问-websocket-与-ajax-的区别" aria-label="Permalink to &quot;问：WebSocket 与 Ajax 的区别&quot;">​</a></h2><h3 id="本质不同" tabindex="-1">本质不同 <a class="header-anchor" href="#本质不同" aria-label="Permalink to &quot;本质不同&quot;">​</a></h3><p>Ajax 即异步 JavaScript 和 XML，是一种创建交互式网页的应用的网页开发技术</p><p>websocket 是 HTML5 的一种新协议，实现了浏览器和服务器的实时通信</p><p>生命周期不同：</p><ul><li>websocket 是长连接，会话一直保持</li><li>ajax 发送接收之后就会断开</li></ul><p>适用范围：</p><ul><li>websocket 用于前后端实时交互数据</li><li>ajax 非实时</li></ul><p>发起人：</p><ul><li>AJAX 客户端发起</li><li>WebSocket 服务器端和客户端相互推送</li></ul><h2 id="了解-websocket-嘛" tabindex="-1">了解 WebSocket 嘛？ <a class="header-anchor" href="#了解-websocket-嘛" aria-label="Permalink to &quot;了解 WebSocket 嘛？&quot;">​</a></h2><p>长轮询和短轮询，WebSocket 是长轮询。</p><p>具体比如在一个电商场景，商品的库存可能会变化，所以需要及时反映给用户，所以客户端会不停的发请求，然后服务器端会不停的去查变化，不管变不变，都返回，这个是短轮询。</p><p>而长轮询则表现为如果没有变，就不返回，而是等待变或者超时（一般是十几秒）才返回，如果没有返回，客户端也不需要一直发请求，所以减少了双方的压力。</p><h4 id="参考链接" tabindex="-1">参考链接 <a class="header-anchor" href="#参考链接" aria-label="Permalink to &quot;参考链接&quot;">​</a></h4><ul><li><a href="https://www.jianshu.com/p/3fc3646fad80" target="_blank" rel="noreferrer">https://www.jianshu.com/p/3fc3646fad80</a></li></ul><h2 id="http-如何实现长连接-在什么时候会超时" tabindex="-1">HTTP 如何实现长连接？在什么时候会超时？ <a class="header-anchor" href="#http-如何实现长连接-在什么时候会超时" aria-label="Permalink to &quot;HTTP 如何实现长连接？在什么时候会超时？&quot;">​</a></h2><p>通过在头部（请求和响应头）设置 Connection: keep-alive，HTTP1.0 协议支持，但是默认关闭，从 HTTP1.1 协议以后，连接默认都是长连接</p><ul><li><p>HTTP 一般会有 httpd 守护进程，里面可以设置 keep-alive timeout，当 tcp 链接闲置超过这个时间就会关闭，也可以在 HTTP 的 header 里面设置超时时间</p></li><li><p>TCP 的 keep-alive 包含三个参数，支持在系统内核的 net.ipv4 里面设置：当 TCP 链接之后，闲置了 tcp_keepalive_time，则会发生侦测包，如果没有收到对方的 ACK，那么会每隔 tcp_keepalive_intvl 再发一次，直到发送了 tcp_keepalive_probes，就会丢弃该链接。</p></li><li><ul><li>tcp_keepalive_intvl = 15</li><li>tcp_keepalive_probes = 5</li><li>tcp_keepalive_time = 1800</li></ul></li></ul><p>实际上 HTTP 没有长短链接，只有 TCP 有，TCP 长连接可以复用一个 TCP 链接来发起多次 HTTP 请求，这样可以减少资源消耗，比如一次请求 HTML，可能还需要请求后续的 JS/CSS/图片等</p><h3 id="参考链接-1" tabindex="-1">参考链接 <a class="header-anchor" href="#参考链接-1" aria-label="Permalink to &quot;参考链接&quot;">​</a></h3><ul><li><a href="https://blog.csdn.net/weixin_37672169/article/details/80283935" target="_blank" rel="noreferrer">https://blog.csdn.net/weixin_37672169/article/details/80283935</a></li><li><a href="https://www.jianshu.com/p/3fc3646fad80" target="_blank" rel="noreferrer">https://www.jianshu.com/p/3fc3646fad80</a></li></ul><h2 id="问-fetch-api-与传统-request-的区别" tabindex="-1">问：Fetch API 与传统 Request 的区别 <a class="header-anchor" href="#问-fetch-api-与传统-request-的区别" aria-label="Permalink to &quot;问：Fetch API 与传统 Request 的区别&quot;">​</a></h2><ul><li>fetch 符合关注点分离，使用 Promise，API 更加丰富，支持 Async/Await</li><li>语意简单，更加语意化</li><li>可以使用 isomorphic-fetch ，同构方便</li></ul><h3 id="参考资源" tabindex="-1">参考资源 <a class="header-anchor" href="#参考资源" aria-label="Permalink to &quot;参考资源&quot;">​</a></h3><ul><li><a href="https://github.com/camsong/blog/issues/2" target="_blank" rel="noreferrer">https://github.com/camsong/blog/issues/2</a></li></ul><h2 id="_2-问-post-一般可以发送什么类型的文件-数据处理的问题" tabindex="-1">（2）问：POST 一般可以发送什么类型的文件，数据处理的问题 <a class="header-anchor" href="#_2-问-post-一般可以发送什么类型的文件-数据处理的问题" aria-label="Permalink to &quot;（2）问：POST 一般可以发送什么类型的文件，数据处理的问题&quot;">​</a></h2><ul><li>文本、图片、视频、音频等都可以</li><li>text/image/audio/ 或 application/json 等</li></ul><h2 id="问-tcp-如何保证有效传输及拥塞控制原理。" tabindex="-1">问：TCP 如何保证有效传输及拥塞控制原理。 <a class="header-anchor" href="#问-tcp-如何保证有效传输及拥塞控制原理。" aria-label="Permalink to &quot;问：TCP 如何保证有效传输及拥塞控制原理。&quot;">​</a></h2><ul><li>tcp 是面向连接的、可靠的、传输层通信协议</li></ul><p>可靠体现在：有状态、可控制</p><ul><li>有状态是指 TCP 会确认发送了哪些报文，接收方受到了哪些报文，哪些没有收到，保证数据包按序到达，不允许有差错</li><li>可控制的是指，如果出现丢包或者网络状况不佳，则会跳转自己的行为，减少发送的速度或者重发</li></ul><p>所以上面能保证数据包的有效传输。</p><h3 id="拥塞控制原理" tabindex="-1">拥塞控制原理 <a class="header-anchor" href="#拥塞控制原理" aria-label="Permalink to &quot;拥塞控制原理&quot;">​</a></h3><p>原因是有可能整个网络环境特别差，容易丢包，那么发送端就应该注意了。</p><p>主要用三种方法：</p><ul><li>慢启动阈值 + 拥塞避免</li><li>快速重传</li><li>快速回复</li></ul><h3 id="慢启动阈值-拥塞避免" tabindex="-1">慢启动阈值 + 拥塞避免 <a class="header-anchor" href="#慢启动阈值-拥塞避免" aria-label="Permalink to &quot;慢启动阈值 + 拥塞避免&quot;">​</a></h3><p>对于拥塞控制来说，TCP 主要维护两个核心状态：</p><ul><li>拥塞窗口（cwnd）</li><li>慢启动阈值（ssthresh）</li></ul><blockquote><p>在发送端使用拥塞窗口来控制发送窗口的大小。</p></blockquote><p>然后采用一种比较保守的慢启动算法来慢慢适应这个网络，在开始传输的一段时间，发送端和接收端会首先通过三次握手建立连接，确定各自接收窗口大小，然后初始化双方的拥塞窗口，接着每经过一轮 RTT（收发时延），拥塞窗口大小翻倍，直到达到慢启动阈值。</p><p>然后开始进行拥塞避免，拥塞避免具体的做法就是之前每一轮 RTT，拥塞窗口翻倍，现在每一轮就加一个。</p><h3 id="快速重传" tabindex="-1">快速重传 <a class="header-anchor" href="#快速重传" aria-label="Permalink to &quot;快速重传&quot;">​</a></h3><p>在 TCP 传输过程中，如果发生了丢包，接收端就会发送之前重复 ACK，比如 第 5 个包丢了，6、7 达到，然后接收端会为 5，6，7 都发送第四个包的 ACK，这个时候发送端受到了 3 个重复的 ACK，意识到丢包了，就会马上进行重传，而不用等到 RTO （超时重传的时间）</p><p>选择性重传：报文首部可选性中加入 SACK 属性，通过 left edge 和 right edge 标志那些包到了，然后重传没到的包</p><h3 id="快速恢复" tabindex="-1">快速恢复 <a class="header-anchor" href="#快速恢复" aria-label="Permalink to &quot;快速恢复&quot;">​</a></h3><p>如果发送端收到了 3 个重复的 ACK，发现了丢包，觉得现在的网络状况已经进入拥塞状态了，那么就会进入快速恢复阶段：</p><ul><li>会将拥塞阈值降低为 拥塞窗口的一半</li><li>然后拥塞窗口大小变为拥塞阈值</li><li>接着 拥塞窗口再进行线性增加，以适应网络状况</li></ul><h2 id="问-option-是干啥的-举个用到-option-的例子" tabindex="-1">问：OPTION 是干啥的？举个用到 OPTION 的例子？ <a class="header-anchor" href="#问-option-是干啥的-举个用到-option-的例子" aria-label="Permalink to &quot;问：OPTION 是干啥的？举个用到 OPTION 的例子？&quot;">​</a></h2><p>旨在发送一种探测请求，以确定针对某个目标地址的请求必须具有怎么样的约束，然后根据约束发送真正的请求。</p><p>比如针对跨域资源的预检，就是采用 HTTP 的 OPTIONS 方法先发送的。用来处理跨域请求</p><h2 id="问-http-知道嘛-哪一层的协议-应用层" tabindex="-1">问：http 知道嘛？哪一层的协议？（应用层） <a class="header-anchor" href="#问-http-知道嘛-哪一层的协议-应用层" aria-label="Permalink to &quot;问：http 知道嘛？哪一层的协议？（应用层）&quot;">​</a></h2><ul><li>灵活可扩展，除了规定空格分隔单词，换行分隔字段以外，其他都没有限制，不仅仅可以传输文本，还可以传输图片、视频等任意资源</li><li>可靠传输，基于 TCP/IP 所以继承了这一特性</li><li>请求-应答，有来有回</li><li>无状态，每次 HTTP 请求都是独立的，无关的、默认不需要保存上下文信息</li></ul><p>缺点：</p><ul><li>明文传输不安全</li><li>复用一个 TCP 链接，会发生对头拥塞</li><li>无状态在长连接场景中，需要保存大量上下文，以避免传输大量重复的信息</li></ul><h2 id="问-osi-七层模型和-tcp-ip-四层模型" tabindex="-1">问：OSI 七层模型和 TCP/IP 四层模型 <a class="header-anchor" href="#问-osi-七层模型和-tcp-ip-四层模型" aria-label="Permalink to &quot;问：OSI 七层模型和 TCP/IP 四层模型&quot;">​</a></h2><ul><li>应用层</li><li>表示层</li><li>会话层</li><li>传输层</li><li>网络层</li><li>数据链路层</li><li>物理层</li></ul><p>TCP/IP 四层概念：</p><ul><li>应用层：应用层、表示层、会话层：HTTP</li><li>传输层：传输层：TCP/UDP</li><li>网络层：网络层：IP</li><li>数据链路层：数据链路层、物理层</li></ul><h2 id="_3-问-tcp-协议怎么保证可靠的-udp-为什么不可靠" tabindex="-1">（3）问：TCP 协议怎么保证可靠的，UDP 为什么不可靠？ <a class="header-anchor" href="#_3-问-tcp-协议怎么保证可靠的-udp-为什么不可靠" aria-label="Permalink to &quot;（3）问：TCP 协议怎么保证可靠的，UDP 为什么不可靠？&quot;">​</a></h2><ul><li>TCP 是面向连接的、可靠的、传输层通信协议</li><li>UDP 是无连接的传输层通信协议，继承 IP 特性,基于数据报</li></ul><p>为什么 TCP 可靠？TCP 的可靠性体现在有状态和控制</p><ul><li>会精准记录那些数据发送了，那些数据被对方接收了，那些没有被接收，而且保证数据包按序到达，不允许半点差错，这就是有状态</li><li>当意识到丢包了或者网络环境不佳，TCP 会根据具体情况调整自己的行为，控制自己的发送速度或者重发，这是可控制的</li></ul><p>反之 UDP 就是无状态的和不可控制的</p><h2 id="输入-url-到渲染的过程" tabindex="-1">输入 url 到渲染的过程 <a class="header-anchor" href="#输入-url-到渲染的过程" aria-label="Permalink to &quot;输入 url 到渲染的过程&quot;">​</a></h2><h2 id="xss、csrf-攻击原理和防范" tabindex="-1">xss、csrf 攻击原理和防范 <a class="header-anchor" href="#xss、csrf-攻击原理和防范" aria-label="Permalink to &quot;xss、csrf 攻击原理和防范&quot;">​</a></h2><h2 id="主动方为什么会等待-2msl" tabindex="-1">主动方为什么会等待 2MSL <a class="header-anchor" href="#主动方为什么会等待-2msl" aria-label="Permalink to &quot;主动方为什么会等待 2MSL&quot;">​</a></h2><h2 id="对-post-和-get-请求的理解" tabindex="-1">对 post 和 get 请求的理解 <a class="header-anchor" href="#对-post-和-get-请求的理解" aria-label="Permalink to &quot;对 post 和 get 请求的理解&quot;">​</a></h2><h2 id="浏览器缓存-强缓存、协商缓存-为什么-cache-control-优先级更高" tabindex="-1">浏览器缓存,强缓存、协商缓存,为什么 cache-control 优先级更高 <a class="header-anchor" href="#浏览器缓存-强缓存、协商缓存-为什么-cache-control-优先级更高" aria-label="Permalink to &quot;浏览器缓存,强缓存、协商缓存,为什么 cache-control 优先级更高&quot;">​</a></h2><h2 id="cookie-的-httponly-是干啥的" tabindex="-1">cookie 的 httpOnly 是干啥的 <a class="header-anchor" href="#cookie-的-httponly-是干啥的" aria-label="Permalink to &quot;cookie 的 httpOnly 是干啥的&quot;">​</a></h2><h2 id="禁止-js-操作获取-cookie" tabindex="-1">禁止 js 操作获取 cookie <a class="header-anchor" href="#禁止-js-操作获取-cookie" aria-label="Permalink to &quot;禁止 js 操作获取 cookie&quot;">​</a></h2><h2 id="cookie-的属性有哪些" tabindex="-1">cookie 的属性有哪些 <a class="header-anchor" href="#cookie-的属性有哪些" aria-label="Permalink to &quot;cookie 的属性有哪些&quot;">​</a></h2><h2 id="强缓存和协商缓存-什么情况下会用到协商缓存" tabindex="-1">强缓存和协商缓存,什么情况下会用到协商缓存？ <a class="header-anchor" href="#强缓存和协商缓存-什么情况下会用到协商缓存" aria-label="Permalink to &quot;强缓存和协商缓存,什么情况下会用到协商缓存？&quot;">​</a></h2><h2 id="cookie-和-session-的区别" tabindex="-1">Cookie 和 Session 的区别 <a class="header-anchor" href="#cookie-和-session-的区别" aria-label="Permalink to &quot;Cookie 和 Session 的区别&quot;">​</a></h2><h2 id="怎么理解端到端的连接" tabindex="-1">怎么理解端到端的连接？ <a class="header-anchor" href="#怎么理解端到端的连接" aria-label="Permalink to &quot;怎么理解端到端的连接？&quot;">​</a></h2><h2 id="tcp" tabindex="-1">TCP <a class="header-anchor" href="#tcp" aria-label="Permalink to &quot;TCP&quot;">​</a></h2><blockquote><p><a href="https://juejin.cn/post/6844903958624878606" target="_blank" rel="noreferrer">面试官，不要再问我三次握手和四次挥手</a></p></blockquote>',173),r=[o];function h(n,s,c,p,d,u){return l(),a("div",null,r)}const b=e(t,[["render",h]]);export{T as __pageData,b as default};
