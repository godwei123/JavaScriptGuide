import{_ as a,c as t,o as l,Q as e}from"./chunks/framework.00751356.js";const i="/javascript-guide/assets/aHR0cDovL2ltZy5.dd8f01e7.png",r="/javascript-guide/assets/aHR0cDovL2ltZy5ibG.6c19016b.png",p="/javascript-guide/assets/20200802172257514.a7e438e6.png",b=JSON.parse('{"title":"TCP 和 UDP","description":"","frontmatter":{},"headers":[],"relativePath":"basic/network/tcp.md","filePath":"basic/network/tcp.md"}'),o={name:"basic/network/tcp.md"},s=e('<h1 id="tcp-和-udp" tabindex="-1">TCP 和 UDP <a class="header-anchor" href="#tcp-和-udp" aria-label="Permalink to &quot;TCP 和 UDP&quot;">​</a></h1><h2 id="tcp-特点" tabindex="-1">TCP 特点 <a class="header-anchor" href="#tcp-特点" aria-label="Permalink to &quot;TCP 特点&quot;">​</a></h2><ul><li>面向连接的传输层协议</li><li>只支持点对点连接（一对一）</li><li>提供可靠交付服务</li><li>提供全双工通信</li><li>面向字节流</li></ul><h2 id="udp-特点" tabindex="-1">UDP 特点 <a class="header-anchor" href="#udp-特点" aria-label="Permalink to &quot;UDP 特点&quot;">​</a></h2><h2 id="tcp-三次握手" tabindex="-1">TCP 三次握手 <a class="header-anchor" href="#tcp-三次握手" aria-label="Permalink to &quot;TCP 三次握手&quot;">​</a></h2><p><img src="'+i+'" alt="三次握手"></p><p>1、TCP 服务器进程先创建传输控制块 TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了 <strong>LISTEN（监听）状态</strong>；</p><p>2、TCP 客户进程也是先创建传输控制块 TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位 SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP 客户端进程进入了 <strong>SYN-SENT（同步已发送状态）状态</strong>。TCP 规定，SYN 报文段（SYN=1 的报文段）不能携带数据，但需要消耗掉一个序号。</p><p>3、TCP 服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是 ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP 服务器进程进入了 <strong>SYN-RCVD（同步收到）状态</strong>。这个报文也不能携带数据，但是同样要消耗一个序号。</p><p>4、TCP 客户进程收到确认后，还要向服务器给出确认。确认报文的 ACK=1，ack=y+1，自己的序列号 seq=x+1，此时，TCP 连接建立，客户端进入 <strong>ESTABLISHED（已建立连接）状态</strong>。TCP 规定，ACK 报文段可以携带数据，但是如果不携带数据则不消耗序号。</p><p>5、当服务器收到客户端的确认后也进入 <strong>ESTABLISHED 状态</strong>，此后双方就可以开始通信了。</p><h2 id="tcp-客户端最后还要发送一次确认呢" tabindex="-1">TCP 客户端最后还要发送一次确认呢？ <a class="header-anchor" href="#tcp-客户端最后还要发送一次确认呢" aria-label="Permalink to &quot;TCP 客户端最后还要发送一次确认呢？&quot;">​</a></h2><p>一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。</p><p>如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于 TCP 的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。</p><p>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p><h3 id="为什么不是两次" tabindex="-1">为什么不是两次？ <a class="header-anchor" href="#为什么不是两次" aria-label="Permalink to &quot;为什么不是两次？&quot;">​</a></h3><blockquote><p>无法确认客户端的接收能力。</p></blockquote><p>如果首先客户端发送了 SYN 报文，但是滞留在网络中，TCP 以为丢包了，然后重传，两次握手建立了连接。</p><p>等到客户端关闭连接了。但是之后这个包如果到达了服务端，那么服务端接收到了，然后发送相应的数据表，就建立了链接，但是此时客户端已经关闭连接了，所以带来了链接资源的浪费。</p><h3 id="为什么不是四次" tabindex="-1">为什么不是四次？ <a class="header-anchor" href="#为什么不是四次" aria-label="Permalink to &quot;为什么不是四次？&quot;">​</a></h3><p>四次以上都可以，只不过 三次就够了</p><h2 id="tcp-四次挥手" tabindex="-1">TCP 四次挥手 <a class="header-anchor" href="#tcp-四次挥手" aria-label="Permalink to &quot;TCP 四次挥手&quot;">​</a></h2><p><img src="'+r+'" alt="aHR0cDovL2ltZy5ibG"></p><p>1、客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为 seq=u（等于前面已经传送过来的数据的最后一个字节的序号加 1），此时，客户端进入 FIN-WAIT-1（终止等待 1）状态。 TCP 规定，FIN 报文段即使不携带数据，也要消耗一个序号。</p><p>2、服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号 seq=v，此时，服务端就进入了 CLOSE-WAIT（关闭等待）状态。TCP 服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个 CLOSE-WAIT 状态持续的时间。</p><p>3、客户端收到服务器的确认请求后，此时，客户端就进入 FIN-WAIT-2（终止等待 2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</p><p>4、服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为 seq=w，此时，服务器就进入了 <strong>LAST-ACK（最后确认）状态</strong>，等待客户端的确认。</p><p>5、客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是 seq=u+1，此时，客户端就进入了 TIME-WAIT（时间等待）状态。注意此时 TCP 连接还没有释放，必须经过 2*MSL（最长报文段寿命）的时间后，当客户端撤销相应的 TCB 后，才进入 CLOSED 状态。</p><p>6、服务器只要收到了客户端发出的确认，立即进入 CLOSED 状态。同样，撤销 TCB 后，就结束了这次的 TCP 连接。可以看到，服务器结束 TCP 连接的时间要比客户端早一些。</p><h2 id="为什么客户端最后还要等待-2msl" tabindex="-1">为什么客户端最后还要等待 2MSL？ <a class="header-anchor" href="#为什么客户端最后还要等待-2msl" aria-label="Permalink to &quot;为什么客户端最后还要等待 2MSL？&quot;">​</a></h2><p>MSL（Maximum Segment Lifetime），TCP 允许不同的实现可以设置不同的 MSL 值。</p><p>第一，保证客户端发送的最后一个 ACK 报文能够到达服务器，因为这个 ACK 报文可能丢失，站在服务器的角度看来，我已经发送了 FIN+ACK 报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个 2MSL 时间段内收到这个重传的报文，接着给出回应报文，并且会重启 2MSL 计时器。</p><p>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个 2MSL 时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p><h2 id="为什么建立连接是三次握手-关闭连接确是四次挥手呢" tabindex="-1">为什么建立连接是三次握手，关闭连接确是四次挥手呢？ <a class="header-anchor" href="#为什么建立连接是三次握手-关闭连接确是四次挥手呢" aria-label="Permalink to &quot;为什么建立连接是三次握手，关闭连接确是四次挥手呢？&quot;">​</a></h2><p>建立连接的时候， 服务器在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。</p><p>而关闭连接时，服务器收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，因此，己方 ACK 和 FIN 一般都会分开发送，从而导致多了一次。</p><h2 id="如果已经建立了连接-但是客户端突然出现故障了怎么办" tabindex="-1">如果已经建立了连接，但是客户端突然出现故障了怎么办？ <a class="header-anchor" href="#如果已经建立了连接-但是客户端突然出现故障了怎么办" aria-label="Permalink to &quot;如果已经建立了连接，但是客户端突然出现故障了怎么办？&quot;">​</a></h2><p>TCP 还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为 2 小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔 75 秒发送一次。若一连发送 10 个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><h2 id="tcp-和-udp-对比" tabindex="-1">TCP 和 UDP 对比 <a class="header-anchor" href="#tcp-和-udp-对比" aria-label="Permalink to &quot;TCP 和 UDP 对比&quot;">​</a></h2><h2 id="tcp-可靠传输" tabindex="-1">TCP 可靠传输 <a class="header-anchor" href="#tcp-可靠传输" aria-label="Permalink to &quot;TCP 可靠传输&quot;">​</a></h2><p>(1) 确认应答（ACK）机制 确认应答：TCP 传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送 ACK 报文。</p><p>TCP 通过确认应答机制实现可靠的数据传输。在 TCP 的首部中有一个标志位——ACK，此标志位表示确认号是否有效。接收方对于按序到达的数据会进行确认，当标志位 ACK=1 时确认首部的确认字段有效。进行确认时，确认字段值表示这个值之前的数据都已经按序到达了。而发送方如果收到了已发送的数据的确认报文，则继续传输下一部分数据；而如果等待了一定时间还没有收到确认报文就会启动重传机制。</p><p>(2) 超时重传机制</p><p>超时重传的两种情况</p><ul><li>如果主机 A 发送给主机 B 的报文，主机 B 在规定的时间内没有及时收到主机 A 发送的报文，我们可以认为是 ACK 丢了，这时就需要触发超时重传机制。</li><li>如果主机 A 未收到 B 发来的确认应答，也可能是因为 ACK 丢了。因此主机 B 会收到很多重复的数据，那么，TCP 协议需要能够识别出那些包是重复的包，并且把重复的包丢弃，这时候我们可以用前面提到的序列号，很容易做到去重的效果</li></ul><h2 id="tcp-流量控制" tabindex="-1">TCP 流量控制 <a class="header-anchor" href="#tcp-流量控制" aria-label="Permalink to &quot;TCP 流量控制&quot;">​</a></h2><p>一般来说，流量控制就是为了让发送方发送数据的速度不要太快，要让接收方来得及接收。TCP 采用大小可变的滑动窗口进行流量控制，窗口大小的单位是字节。这里说的窗口大小其实就是每次传输的数据大小。</p><ul><li>当一个连接建立时，连接的每一端分配一个缓冲区来保存输入的数据，并将缓冲区的大小发送给另一端。</li><li>当数据到达时，接收方发送确认，其中包含了自己剩余的缓冲区大小。（剩余的缓冲区空间的大小被称为窗口，指出窗口大小的通知称为窗口通告。接收方在发送的每一确认中都含有一个窗口通告。）</li><li>如果接收方应用程序读数据的速度能够与数据到达的速度一样快，接收方将在每一确认中发送一个正的窗口通告。</li><li>如果发送方操作的速度快于接收方，接收到的数据最终将充满接收方的缓冲区，导致接收方通告一个零窗口 。发送方收到一个零窗口通告时，必须停止发送，直到接收方重新通告一个正的窗口。(窗口探测)</li></ul><p><strong>TCP 的可靠传输机制是基于连续 ARQ 协议和滑动窗口协议的。</strong></p><p>TCP 协议在发送方维持了一个发送窗口，发送窗口以前的报文段是已经发送并确认了的报文段，发送窗口中包含了已经发送但 未确认的报文段和允许发送但还未发送的报文段，发送窗口以后的报文段是缓存中还不允许发送的报文段。当发送方向接收方发 送报文时，会依次发送窗口内的所有报文段，并且设置一个定时器，这个定时器可以理解为是最早发送但未收到确认的报文段。 如果在定时器的时间内收到某一个报文段的确认回答，则滑动窗口，将窗口的首部向后滑动到确认报文段的后一个位置，此时如果还有已发送但没有确认的报文段，则重新设置定时器，如果没有了则关闭定时器。如果定时器超时，则重新发送所有已经发送 但还未收到确认的报文段，并将超时的间隔设置为以前的两倍。当发送方收到接收方的三个冗余的确认应答后，这是一种指示， 说明该报文段以后的报文段很有可能发生丢失了，那么发送方会启用快速重传的机制，就是当前定时器结束前，发送所有的已发 送但确认的报文段。</p><p>接收方使用的是累计确认的机制，对于所有按序到达的报文段，接收方返回一个报文段的肯定回答。如果收到了一个乱序的报文 段，那么接方会直接丢弃，并返回一个最近的按序到达的报文段的肯定回答。使用累计确认保证了返回的确认号之前的报文段都已经按序到达了，所以发送窗口可以移动到已确认报文段的后面。 发送窗口的大小是变化的，它是由接收窗口剩余大小和网络中拥塞程度来决定的，TCP 就是通过控制发送窗口的长度来控制报文 段的发送速率。 但是 TCP 协议并不完全和滑动窗口协议相同，因为许多的 TCP 实现会将失序的报文段给缓存起来，并且发生重传时，只会重 传一个报文段，因此 TCP 协议的可靠传输机制更像是窗口滑动协议和选择重传协议的一个混合体。</p><h3 id="连续-arq-协议" tabindex="-1">连续 ARQ 协议 <a class="header-anchor" href="#连续-arq-协议" aria-label="Permalink to &quot;连续 ARQ 协议&quot;">​</a></h3><p>接收方一般都是采用累积确认的方式。也就是说，接收方不必对收到的分组逐个发送确认，而是在收到几个分组后，对按序到达的最后一个分组发送确认。这就表示到这个分组为止的所有分组都已正确收到了。</p><p>累积确认有优点也有缺点。优点是：容易实现，即使确认丢失也不必重传。但缺点是不能向发送方反映出接收方已经正确收到的所有分组的信息。</p><p>例如，如果发送方发送了前 5 个分组，而第 3 个分组丢失了。此时接收方只能对前两个分组发出确认，因为接收方只能对按需到达的最后一个分组发送确认。发送方无法知道后面三个分组的下落，只好把后面的三个分组都再重传一次。这就叫做 Go-back-N（回退 N），表示需要再退回来重传已发送过的 N 个分组。</p><h2 id="tcp-拥塞控制" tabindex="-1">TCP 拥塞控制 <a class="header-anchor" href="#tcp-拥塞控制" aria-label="Permalink to &quot;TCP 拥塞控制&quot;">​</a></h2><p>TCP 的拥塞控制机制主要是以下四种机制：</p><ul><li>慢启动（慢开始）</li><li>拥塞避免</li><li>快速重传</li><li>快速恢复</li></ul><p>（1）慢启动（慢开始）</p><ul><li>在开始发送的时候设置 cwnd = 1（cwnd 指的是拥塞窗口）</li><li>思路：开始的时候不要发送大量数据，而是先测试一下网络的拥塞程度，由小到大增加拥塞窗口的大小。</li><li>为了防止 cwnd 增长过大引起网络拥塞，设置一个慢开始门限(ssthresh 状态变量) <ul><li>当 cnwd &lt; ssthresh，使用慢开始算法</li><li>当 cnwd = ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法</li><li>当 cnwd &gt; ssthresh，使用拥塞避免算法</li></ul></li></ul><p>（2）拥塞避免</p><ul><li>拥塞避免未必能够完全避免拥塞，是说在拥塞避免阶段将拥塞窗口控制为按线性增长，使网络不容易出现阻塞。</li><li>思路： 让拥塞窗口 cwnd 缓慢的增大，即每经过一个返回时间 RTT 就把发送方的拥塞控制窗口加一</li><li>无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞，就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为 1，执行慢开始。</li></ul><p>其中，判断网络出现拥塞的根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理。** 判断网络拥塞的依据就是出现了超时。**</p><p><img src="'+p+'" alt=""></p><p>（3）快速重传</p><ul><li>快重传要求接收方在收到一个失序的报文段后就立即发出重复确认(为的是使发送方及早知道有报文段没有到达对方) 。发送方只要连续收到三个重复确认就立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</li><li>由于不需要等待设置的重传计时器到期，能尽早重传未被确认的报文段，能提高整个网络的吞吐量</li></ul><p>（4）快速恢复</p><ul><li><strong>当发送方连续收到三个重复确认</strong>时，就执行“乘法减小”算法，把 ssthresh 门限减半。但是接下去并不执行慢开始算法。</li><li>考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将 cwnd 设置为 ssthresh 的大小，然后执行拥塞避免算法。</li></ul><h2 id="tcp-怎么判断丢包" tabindex="-1">TCP 怎么判断丢包 <a class="header-anchor" href="#tcp-怎么判断丢包" aria-label="Permalink to &quot;TCP 怎么判断丢包&quot;">​</a></h2><h2 id="tcp-的重传机制" tabindex="-1">TCP 的重传机制 <a class="header-anchor" href="#tcp-的重传机制" aria-label="Permalink to &quot;TCP 的重传机制&quot;">​</a></h2><p>由于 TCP 的下层网络（网络层）可能出现丢失、重复或失序的情况，TCP 协议提供可靠数据传输服务。为保证数据传输的正确性，TCP 会重传其认为已丢失（包括报文中的比特错误）的包。TCP 使用两套独立的机制来完成重传，一是基于时间，二是基于确认信息。</p><p>TCP 在发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到发送数据的 ACK 确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。</p><h2 id="udp-不稳定怎么解决" tabindex="-1">udp 不稳定怎么解决 <a class="header-anchor" href="#udp-不稳定怎么解决" aria-label="Permalink to &quot;udp 不稳定怎么解决&quot;">​</a></h2><ul><li>增加系统发送或接收缓冲区大小</li><li>增加应答机制，处理完一个包后，在继续发包</li><li>控制报文大小</li></ul>',74),c=[s];function h(n,d,P,C,u,T){return l(),t("div",null,c)}const m=a(o,[["render",h]]);export{b as __pageData,m as default};
