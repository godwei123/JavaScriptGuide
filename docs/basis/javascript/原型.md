# 原型

JavaScript中的对象有一个特殊的[[Prototype]]内置属性，其实就是对于其他对象的引用。几乎所有的对象在创建时[[Prototype]]属性都会被赋予一个非空的值。



Object.create(..)的原理，它会创建一个对象并把这个对象的[[Prototype]]关联到指定的对象。



使用for..in遍历对象时原理和查找[[Prototype]]链类似，任何可以通过原型链访问到（并且是enumerable）的属性都会被枚举。

使用in操作符来检查属性在对象中是否存在时，同样会查找对象的整条原型链**（无论属性是否可枚举）**



对原型链上层属性赋值存在3种情况：

- 该属性只读，不可赋值，严格模式报错，非严格模式忽略该操作
- 该属性存在setter，调用setter赋值
- 如果不是以上两种情况，在下层创建同名的属性并赋值，屏蔽上层属性。



**隐式屏蔽**

```javascript
let another = {
    a:2
}
let myObj = Object.create(another)

console.log(another.a); // 2
console.log(myObj.a); // 2
console.log(another.hasOwnProperty("a")); // true
console.log(myObj.hasOwnProperty("a")); // false

myObj.a++; // 隐式屏蔽

console.log(another.a); // 2
console.log(myObj.a); // 3
console.log(another.hasOwnProperty("a")); // true
console.log(myObj.hasOwnProperty("a")); // true
```





所有的函数默认都会拥有一个名为prototype的公有并且不可枚举的属性，它会指向另一个对象。



继承意味着复制操作，JavaScript（默认）并不会复制对象属性。相反，JavaScript会在两个对象之间创建一个关联，这样一个对象就可以通过委托访问另一个对象的属性和函数。



实际上，函数本身并不是构造函数，然而，当你在普通的函数调用前面加上new关键字之后，就会把这个函数调用变成一个“构造函数调用”。实际上，new会劫持所有普通函数并用构造对象的形式来调用它。

换句话说，在JavaScript中对于“构造函数”最准确的解释是，所有带new的函数调用。函数不是构造函数，但是当且仅当使用new时，函数调用会变成“构造函数调用”。







# 继承

```
Object.setPrototypeOf(Bar.prototype,Foo.prototype)

Bar.prototype = Object.create(Foo.prototype)

```



如果使用内置的．bind(..)函数来生成一个硬绑定函数的话，该函数是没有 prototype 属性的

instanceof

Foo.prototype.isPrototypeOf(a)  // a 的整条[[Prototype]]是否出现过Foo.prototype





Object.getPrototypeOf(obj) 获取一个对象的[[Prototype]]链

Object.setPrototypeOf(obj1,obj2) 设置属性





Object.create(..)会创建一个新对象（bar）并把它关联到我们指定的对象（foo），这样我们就可以充分发挥[[Prototype]]机制的威力（委托）并且避免不必要的麻烦（比如使用new的构造函数调用会生成．prototype和．constructor引用）。



Object.create(null)会创建一个拥有空（或者说null）[[Prototype]]链接的对象，这个对象无法进行委托。由于这个对象没有原型链，所以instanceof操作符（之前解释过）无法进行判断，因此总是会返回false。这些特殊的空[[Prototype]]对象通常被称作“字典”，它们完全不会受到原型链的干扰，因此非常适合用来存储数据。



Object.create(..)的第二个参数指定了需要添加到新对象中的属性名以及这些属性的属性描述符。





```javascript
Object.create = function (o){
    function F(){}
    F.prototype = o
    return new F()
}
```







## 委托

委托行为意味着某些对象在找不到属性或者方法引用时会把这个请求委托给另一个对象。

匿名函数没有name标识符，这会导致：
1．调试栈更难追踪；
2．自我引用（递归、事件（解除）绑定，等等）更难；
3．代码（稍微）更难理解。

使用简洁方法时一定要小心这一点。如果你需要自我引用的话，那最好使用传统的具名函数表达式来定义对应的函数（· baz: function baz(){..}·），不要使用简洁方法。



行为委托认为对象之间是兄弟关系，互相委托，而不是父类和子类的关系。JavaScript的[[Prototype]]机制本质上就是行为委托机制。也就是说，我们可以选择在JavaScript中努力实现类机制，也可以拥抱更自然的[[Prototype]]委托机制。













## 描述下 JavaScript 中 Scope（作用域）、Closure（闭包）、Prototype（原型） 概念，

## 说明 JavaScript 封装、继承实现原理
