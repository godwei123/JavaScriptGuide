# TCP & UDP

## TCP

TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。其主要特点包括：

- 面向连接的传输层协议：TCP 在数据传输前，需要先建立连接，数据的发送和接收是有序的。
- 只支持点对点连接（一对一）：TCP 不支持广播和多播传输。
- 提供可靠交付服务：TCP 提供了确认、重传、错误检测等机制，保证了数据的可靠传输。
- 提供全双工通信：TCP 的通信双方都能同时发送和接收数据。
- 面向字节流：TCP 把应用层传下来的数据看作一连串无结构的字节流，没有边界。

TCP 适用于对数据传输的可靠性要求较高的场景，如文件传输、邮件发送等。

## UDP

UDP（User Datagram Protocol，用户数据报协议）是一种面向无连接的传输层通信协议。其主要特点包括：

- 面向无连接：UDP 不需要在发送数据之前建立连接，数据的发送和接收是独立的。
- 不可靠性：UDP 不提供数据到达确认，错误重传或者拥塞控制等机制，因此它的传输可靠性较差。
- 高效性：由于 UDP 没有复杂的控制机制，因此在处理速度上，相比于 TCP 会更高效。
- 支持一对一、一对多、多对一和多对多的交互通信。
- 数据报文的首部开销小，仅有 8 个字节，相比 TCP 的 20 个字节要小得多。

UDP 常用于对实时性要求较高的服务，如视频会议、网络语音电话等。

## TCP 三次握手

![三次握手](../public/aHR0cDovL2ltZy5.png)

1. TCP 服务器进程先创建传输控制块 TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了 **LISTEN 状态**；
2. TCP 客户进程也是先创建传输控制块 TCB，然后向服务器发出连接请求报文。SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP 客户端进程进入了 **SYN-SENT 状态**。TCP 规定，SYN 的报文段不能携带数据，但需要消耗掉一个序号。
3. TCP 服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中 ACK=1，SYN=1，确认号是 ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时 TCP 服务器进程进入了**SYN-RCVD 状态**。这个报文也不能携带数据，但是同样要消耗一个序号。
4. TCP 客户进程收到确认后，还要向服务器给出确认。确认报文的 ACK=1，ack=y+1，自己的序列号 seq=x+1，此时，TCP 连接建立，客户端进入 **ESTABLISHED 状态**。TCP 规定，ACK 报文段可以携带数据，但是如果不携带数据则不消耗序号。
5. 当服务器收到客户端的确认后也进入 **ESTABLISHED 状态**，此后双方就可以开始通信了。

## TCP 客户端最后为什么还要发送一次确认

主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。

如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于 TCP 的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。

### 为什么不是两次

> 无法确认客户端的接收能力。

如果首先客户端发送了 SYN 报文，但是滞留在网络中，TCP 以为丢包了，然后重传，两次握手建立了连接。等到客户端关闭连接了。但是之后这个包如果到达了服务端，那么服务端接收到了，然后发送相应的数据表，就建立了链接，但是此时客户端已经关闭连接了，所以带来了链接资源的浪费。

## TCP 四次挥手

![aHR0cDovL2ltZy5ibG](../public/aHR0cDovL2ltZy5ibG.png)

1. 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为 seq=u（等于前面已经传送过来的数据的最后一个字节的序号加 1），此时，客户端进入 FIN-WAIT-1（终止等待 1）状态。 TCP 规定，FIN 报文段即使不携带数据，也要消耗一个序号。
2. 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号 seq=v，此时，服务端就进入了 CLOSE-WAIT（关闭等待）状态。TCP 服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即**客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受**。这个状态要持续一段时间，也就是整个 CLOSE-WAIT 状态持续的时间。
3. 客户端收到服务器的确认请求后，客户端就进入 FIN-WAIT-2（终止等待 2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
4. 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为 seq=w，此时，服务器就进入了 **LAST-ACK（最后确认）状态**，等待客户端的确认。
5. 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是 seq=u+1，此时，客户端就进入了 TIME-WAIT（时间等待）状态。注意此时 TCP 连接还没有释放，必须经过 2\*MSL（最长报文段寿命）的时间后，才进入 CLOSED 状态。
6. 服务器只要收到了客户端发出的确认，立即进入 CLOSED 状态。结束了这次的 TCP 连接。可以看到，服务器结束 TCP 连接的时间要比客户端早一些。

## 为什么客户端最后还要等待 2MSL

第一，保证客户端发送的最后一个 ACK 报文能够到达服务器，因为这个 ACK 报文可能丢失，站在服务器的角度看来，我已经发送了 FIN+ACK 报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个 2MSL 时间段内收到这个重传的报文，接着给出回应报文，并且会重启 2MSL 计时器。

第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个 2MSL 时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。

## 为什么建立连接是三次握手，关闭连接确是四次挥手呢？

建立连接的时候，服务器在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。 而关闭连接时，服务器收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，因此，己方 ACK 和 FIN 一般都会分开发送，从而导致多了一次。

## 如果已经建立了连接，但是客户端突然出现故障了怎么办？

TCP 设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为 2 小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔 75 秒发送一次。若一连发送 10 个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

## TCP 可靠传输

- 确认应答（ACK）机制：TCP 传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答，就是发送 ACK 报文。 TCP 通过确认应答机制实现可靠的数据传输。在 TCP 的首部中有一个标志位——ACK，此标志位表示确认号是否有效。接收方对于按序到达的数据会进行确认，当标志位 ACK=1 时确认首部的确认字段有效。进行确认时，确认字段值表示这个值之前的数据都已经按序到达了。而发送方如果收到了已发送的数据的确认报文，则继续传输下一部分数据；而如果等待了一定时间还没有收到确认报文就会启动重传机制。

- 超时重传机制，超时重传的两种情况：
  - 如果主机 A 发送给主机 B 的报文，主机 B 在规定的时间内没有及时收到主机 A 发送的报文，我们可以认为是 ACK 丢了，这时就需要触发超时重传机制。
  - 如果主机 A 未收到 B 发来的确认应答，也可能是因为 ACK 丢了。因此主机 B 会收到很多重复的数据，那么，TCP 协议需要能够识别出那些包是重复的包，并且把重复的包丢弃，这时候我们可以用前面提到的序列号，很容易做到去重的效果

## TCP 流量控制

一般来说，流量控制就是为了让发送方发送数据的速度不要太快，要让接收方来得及接收。TCP 采用大小可变的滑动窗口进行流量控制，窗口大小的单位是字节。这里说的窗口大小其实就是每次传输的数据大小。

- 当一个连接建立时，连接的每一端分配一个缓冲区来保存输入的数据，并将缓冲区的大小发送给另一端。
- 当数据到达时，接收方发送确认，其中包含了自己剩余的缓冲区大小。（剩余的缓冲区空间的大小被称为窗口，指出窗口大小的通知称为窗口通告。接收方在发送的每一确认中都含有一个窗口通告。）
- 如果接收方应用程序读数据的速度能够与数据到达的速度一样快，接收方将在每一确认中发送一个正的窗口通告。
- 如果发送方操作的速度快于接收方，接收到的数据最终将充满接收方的缓冲区，导致接收方通告一个零窗口 。发送方收到一个零窗口通告时，必须停止发送，直到接收方重新通告一个正的窗口。(窗口探测)

## 滑动窗口协议

TCP 协议在发送方维持了一个发送窗口，发送窗口以前的报文段是已经发送并确认了的报文段，发送窗口中包含了已经发送但未确认的报文段和允许发送但还未发送的报文段，发送窗口以后的报文段是缓存中还不允许发送的报文段。当发送方向接收方发送报文时，会依次发送窗口内的所有报文段，并且设置一个定时器，这个定时器可以理解为是最早发送但未收到确认的报文段。如果在定时器的时间内收到某一个报文段的确认回答，则滑动窗口，将窗口的首部向后滑动到确认报文段的后一个位置，此时如果还有已发送但没有确认的报文段，则重新设置定时器，如果没有了则关闭定时器。如果定时器超时，则重新发送所有已经发送但还未收到确认的报文段，并将超时的间隔设置为以前的两倍。**当发送方收到接收方的三个冗余的确认应答后**，说明该报文段以后的报文段很有可能发生丢失了，那么发送方会启用快速重传的机制。

接收方使用的是累计确认的机制，对于所有按序到达的报文段，接收方返回一个报文段的肯定回答。如果收到了一个乱序的报文段，那么接方会直接丢弃，并返回一个最近的按序到达的报文段的肯定回答。使用累计确认保证了返回的确认号之前的报文段都已经按序到达了，所以发送窗口可以移动到已确认报文段的后面。发送窗口的大小是变化的，它是由接收窗口剩余大小和网络中拥塞程度来决定的，TCP 就是通过控制发送窗口的长度来控制报文段的发送速率。但是 TCP 协议并不完全和滑动窗口协议相同，因为许多的 TCP 实现会将失序的报文段给缓存起来，并且发生重传时，只会重传一个报文段，因此 TCP 协议的可靠传输机制更像是窗口滑动协议和选择重传协议的一个混合体。

## 连续 ARQ 协议

接收方一般都是采用累积确认的方式。也就是说，接收方不必对收到的分组逐个发送确认，而是在收到几个分组后，对按序到达的最后一个分组发送确认。这就表示到这个分组为止的所有分组都已正确收到了。

累积确认有优点也有缺点。优点是：容易实现，即使确认丢失也不必重传。但缺点是不能向发送方反映出接收方已经正确收到的所有分组的信息。 例如，如果发送方发送了前 5 个分组，而第 3 个分组丢失了。此时接收方只能对前两个分组发出确认，因为接收方只能对按需到达的最后一个分组发送确认。发送方无法知道后面三个分组的下落，只好把后面的三个分组都再重传一次。这就叫做 Go-back-N（回退 N），表示需要再退回来重传已发送过的 N 个分组。

## TCP 拥塞控制 🌟

TCP 的拥塞控制机制主要是以下四种机制：

- 慢启动（慢开始）
- 拥塞避免
- 快速重传
- 快速恢复

![拥塞控制](../public/v2-46e70389cb9716aa31b85237e5c74a25_r.png)

### 慢启动

刚开始进入传输数据的时候，你是不知道现在的网路到底是稳定还是拥堵的，如果做的太激进，发包太急，那么疯狂丢包，造成雪崩式的网络灾难。 因此，拥塞控制首先就是要采用一种保守的算法来慢慢地适应整个网路，这种算法叫慢启动。运作过程如下:

- 在开始发送的时候设置 cwnd = 1（cwnd 指的是拥塞窗口）
- 为了防止 cwnd 增长过大引起网络拥塞，设置一个慢开始门限(ssthresh 状态变量)
  - 当 cnwd < ssthresh，使用慢开始算法
  - 当 cnwd = ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法
  - 当 cnwd > ssthresh，使用拥塞避免算法

### 拥塞避免

拥塞避免未必能够完全避免拥塞，是说在拥塞避免阶段将拥塞窗口控制为按线性增长，使网络不容易出现阻塞。 让拥塞窗口 cwnd 缓慢的增大，即每经过一个返回时间 RTT 就把发送方的拥塞控制窗口加一。

无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞，就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为 1，执行慢开始。 其中，**判断网络出现拥塞的根据就是没有收到确认（超时）**，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理。

### 快速重传

快重传要求接收方在收到一个失序的报文段后就立即发出重复确认(为的是使发送方及早知道有报文段没有到达对方)。发送方只要连续收到三个重复确认就立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。

### 快速恢复

**当发送方连续收到三个重复确认**时，就执行“乘法减小”算法，把 ssthresh 门限减半。但是接下去并不执行慢开始算法。考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将 cwnd 设置为 ssthresh 的大小，然后执行拥塞避免算法。

## TCP 重传机制

由于 TCP 的下层网络（网络层）可能出现丢失、重复或失序的情况，TCP 协议提供可靠数据传输服务。为保证数据传输的正确性，TCP 会重传其认为已丢失（包括报文中的比特错误）的包。TCP 使用两套独立的机制来完成重传，一是基于时间，二是基于确认信息。 TCP 在发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到发送数据的 ACK 确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。

## TCP 粘包问题

TCP 粘包问题是指发送方发送的若干包数据到达接收方时，被接收方读取为一个数据包。这主要是由于 TCP 是一个基于字节流的协议，数据的发送和接收是连续无边界的，所以在接收数据时可能会出现一个接收操作读取了多个发送操作发送的数据包，这就是所谓的"粘包"。

粘包问题的产生主要有以下几个原因：

1. 应用程序写入数据的字节大小大于套接字发送缓冲区的大小。
2. 进行了多次写入操作，而接收方不能及时接收数据。
3. TCP 为了提高网络的有效载荷，使用了 Nagle 算法，将小的数据包组合成大的数据包进行发送。

解决粘包问题的常用方法有以下几种：

1. 固定长度：如果所有的数据包长度都是固定的，那么就很容易避免粘包问题，接收方每次只需要接收固定长度的数据即可。
2. 分隔符：如果数据包之间可以用特殊的字符进行分隔，那么接收方可以通过这个分隔符来识别数据包的边界。
3. 添加长度字段：在数据包开始的地方添加一个长度字段，表示本次发送的数据长度，这样接收方在接收到数据后，先读取长度字段，然后再根据长度字段的值来接收指定长度的数据。
4. 使用应用层协议：例如 HTTP、FTP、SMTP 等协议，都在应用层定义了自己的数据传输格式，可以很好地解决粘包问题。

## TCP 和 UDP 的区别

TCP（传输控制协议）和 UDP（用户数据报协议）都是传输层协议，但它们之间存在几个主要的区别：

1. 连接：TCP 是面向连接的协议，这意味着在发送数据之前需要建立连接。而 UDP 是无连接的协议，它不需要建立连接就可以发送数据。
2. 可靠性：TCP 提供可靠的数据传输。它确保所有数据包按正确的顺序到达目的地。如果数据包丢失或损坏，TCP 将重新传输数据包。而 UDP 则不提供任何交付、顺序或错误检查的保证。
3. 速度：由于 UDP 不需要建立连接，不提供可靠性，并且开销较小，因此 UDP 比 TCP 快。
4. 使用场景：当可靠性比速度更重要时，例如在文件传输、电子邮件或网络浏览中，使用 TCP。当速度比可靠性更重要时，例如在视频流或在线游戏中，使用 UDP。
5. 报头大小：TCP 的报头大小（20 字节）比 UDP（8 字节）大，这意味着在带宽使用方面，UDP 更有效率。
6. 流量控制：TCP 使用流量控制来防止发送方用数据淹没接收方。UDP 没有这个特性。
7. 拥塞控制：TCP 有拥塞控制机制来防止网络拥塞，而 UDP 没有。
8. 通信类型：TCP 只支持一对一的通信，而 UDP 支持一对一、一对多、多对一和多对多的通信。
9. 确认：TCP 使用确认来确认接收到数据包。UDP 不使用确认。
10. 全双工：TCP 是全双工协议，这意味着数据可以同时发送和接收。UDP 不支持全双工通信。
