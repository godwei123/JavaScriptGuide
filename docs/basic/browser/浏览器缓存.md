# 浏览器缓存

- 减少了服务器的负担，提高了网站的性能,减少了多余网络数据传输
- 加快了客户端网页的加载速度,减少了用户等待时间

## 浏览器缓存过程

![32362e706e67](../../public/32362e706e67.png)

## 强缓存

使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 Expires 属性和 Cache-Control 属性。

服务器通过在响应头中添加 Expires 属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。Expires 是 http1.0 中的方式，因为它的一些缺点，在 HTTP 1.1 中提出了一个新的头部属性就是 Cache-Control 属性，它提供了对资源的缓存的更精确的控制。

## 协商缓存

如果命中强制缓存，我们无需发起新的请求，直接使用缓存内容，如果没有命中强制缓存，如果设置了协商缓存，这个时候协商缓存就会发挥作用了。命中协商缓存的条件有两个：

- max-age=xxx 过期了
- Cache-Control 值为 no-cache

使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。如果资源发生了修改，则返回修改后的资源。协商缓存也可以通过两种方式来设置，分别是 http 头信息中的 Etag 和 Last-Modified 属性。

### Last-Modified

服务器通过在响应头中添加 Last-Modified 属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个 If-Modified-Since 的属性，属性值为上一次资源返回时的 Last-Modified 的值。当请求发送到服务器后，服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回 304 状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修改后的资源。

**缺点：** Last-Modified 标注的最后修改时间只能精确到秒级，如果某些文件在 1 秒钟以内，被修改多次的话，那么文件已将改变了，但是 Last-Modified 却没有改变，这样会造成缓存命中的不准确。

### Etag

http 中提供了另外一种方式是 Etag 属性。服务器在返回资源的时候，在头信息中添加了 Etag 属性，这个属性是资源生成的唯一标识符，当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，浏览器会在请求头中添加一个 If-None-Match 属性，这个属性的值就是上次返回的资源的 Etag 的值。服务接收到请求后会根据这个值来和资源当前的 Etag 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。

当 Last-Modified 和 Etag 属性同时出现的时候，Etag 的优先级更高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的
Last-Modified 应该保持一致，因为每个服务器上 Etag 的值都不一样，**因此在考虑负载平衡时，最好不要设置 Etag 属性。**

## Cache-Control

| 属性             | 说明                                                                                                 |
| ---------------- | ---------------------------------------------------------------------------------------------------- |
| public           | 表示可以被任何对象（包括:发送请求的客户端、代理服务器等等）缓存。                                    |
| private          | 只能被用户浏览器缓存，不允许任何代理服务器缓存。                                                     |
| no-cache         | 设置了该字段需要先和服务端确认返回的资源是否发生了变化，如果资源未发生变化，则直接使用缓存好的资源。 |
| no-store         | 设置了该字段表示禁止任何缓存，每次都会向服务端发起新的请求，拉取最新的资源。                         |
| max-age=         | 设置缓存的最大有效期，单位为秒。                                                                     |
| s-maxage=        | 优先级高于 max-age=，仅适用于共享缓存(CDN)。                                                         |
| max-stale=       | 设置了该字段表明客户端愿意接收已经过期的资源，但是不能超过给定的时间限制。                           |
| min-fresh=       | 设置了该字段表明客户端希望在指定的时间内获取最新的响应。                                             |
| must-revalidate  | 设置了该字段表明客户端必须向服务端验证缓存是否过期。                                                 |
| proxy-revalidate | 设置了该字段表明共享缓存必须向服务端验证缓存是否过期。                                               |
| immutable        | 设置了该字段表明资源是不可变的，可以直接从本地缓存中获取，不需要再次验证。                           |
| no-transform     | 设置了该字段表明代理服务器不能改变响应的内容。                                                       |

**no-cache 和 no-store 很容易混淆:**

- no-cache 是指先要和服务器确认是否有资源更新。也就是说没有强缓存，但是会有协商缓存；
- no-store 是指不使用任何缓存，每次请求都直接从服务器获取资源。

**点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？**

- 点击刷新按钮或者按 F5:浏览器直接对本地的缓存文件过期，但是会带上 If-Modifed-Since，If-None-Match，这就意味着服务器会对文件检查新鲜度，返回结果可能是 304，也有可能是 200。
- 用户按 Ctrl+F5（强制刷新）:浏览器不仅会对本地文件过期，而且不会带上 If-Modifed-Since，If-None-Match，相当于之前从来没有请求过，返回结果是
  200。
- 地址栏回车: 浏览器发起请求，按照正常流程，本地检查是否过期，然后服务器检查新鲜度，最后返回内容。
