# HTTP

## HTTP 协议

超文本传输协议（HTTP，HyperText Transfer Protocol) 主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。 HTTP 协是基于 TCP 协议，发送 HTTP 请求之前首先要建立 TCP 连接，也就是要经历 3 次握手。目前使用的 HTTP 协议大部分都是 1.1。另外， HTTP 协议是”无状态”的协议，它无法记录客户端用户的状态。htt 具有以下特点：

- 灵活可扩展，除了规定空格分隔单词，换行分隔字段以外，其他都没有限制，不仅仅可以传输文本，还可以传输图片、视频等任意资源
- 可靠传输，基于 TCP/IP，所以继承了这一特性
- 请求-应答，有来有回
- 无状态，每次 HTTP 请求都是独立的，无关的、默认不需要保存上下文信息

**缺点：**

- 明文传输不安全
- 复用一个 TCP 链接，会发生队头拥塞
- 无状态在长连接场景中，需要保存大量上下文，以避免传输大量重复的信息

## HTTP 状态码

- 1xx：表示目前是协议的中间状态，还需要后续请求
- 2xx：表示请求成功
- 3xx：表示重定向状态，需要重新请求
- 4xx：表示客户端错误
- 5xx：服务器端错误

常用状态码：

- 101 切换请求协议，从 HTTP 切换到 WebSocket
- 200 请求成功，有响应体
- 204 No Content，请求成功，返回响应报文不包含实体
- 206 客户端进行了范围请求，响应报文包含 content-range 指定范围的实体内容
- 301 永久重定向：会缓存
- 302 临时重定向：不会缓存
- 303 请求资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源
- 304 Not Modified ，协商缓存命中
- 307 临时重定向，不会从 post 变为 get
- 400 Bad Request 请求错误
- 401 用户认证失败
- 403 服务器禁止访问，访问拒绝
- 404 资源未找到
- 500 服务器端错误
- 503 服务器繁忙

## OPTIONS 请求方法

OPTIONS 请求方法是 HTTP 协议中的一种请求类型。它用于获取目标资源所支持的通信选项。客户端可以向服务器发送 OPTIONS 请求，以确定服务器支持哪些方法和功能。

例如，客户端可以发送一个 OPTIONS 请求来查看服务器是否支持 PUT 或 DELETE 方法。服务器会在响应头的"Allow"字段中返回支持的方法，如"GET, POST, DELETE"等。

OPTIONS 请求的一个常见用途是"CORS"（跨源资源共享）预检请求。在执行可能对服务器数据产生副作用的某些类型的跨域请求（如 PUT，DELETE，以及带特定头信息的 POST 请求）之前，浏览器会先发送一个 OPTIONS 请求，询问服务器是否允许这样的请求。服务器如果允许，会在响应头中包含适当的 CORS 头信息。

在 JavaScript 中，可以使用 fetch API 来发送 OPTIONS 请求，如下所示：

```javascript
fetch("https://example.com", {
  method: "OPTIONS",
})
  .then((response) => response.text())
  .then((data) => console.log(data))
  .catch((error) => console.error("Error:", error));
```

这段代码会向'https://example.com'发送一个OPTIONS请求，并打印出响应的内容。

## post 和 get 请求

POST 和 GET 是 HTTP 协议中两种最常见的请求方法，它们的主要区别如下：

1. 数据传输方式：GET 请求的数据会附加在 URL 之后（就是把数据放置在 HTTP 协议头中），以?分割 URL 和传输数据，参数之间以&相连。而 POST 方法是把提交的数据放置在 HTTP 包的 body 中。

2. 数据安全性：POST 的安全性较 GET 的安全性高。通过 GET 方法提交的数据，用户名和密码将明文出现在 URL 上，因为数据在地址栏上是可见的，所以 GET 不适合传输敏感信息。而 POST 方法由于将数据放在请求的 body 中，所以安全性较高。

3. 数据长度：对于 GET 方法，由于浏览器对 URL 的长度存在限制，所以传输的数据长度会有限制。而 POST 方法由于其将数据放在请求的 body 中，所以理论上数据长度无限制。

4. 缓存：GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认情况下不会。

5. 数据类型：GET 只允许 ASCII 字符数据类型，POST 没有限制。可以传输任何类型的数据，一般使用 POST 方法提交表单。

6. 服务器处理：对于 GET 方式的请求，服务器会把我们的输入数据和表单内的字段进行一一对应，对于 POST，浏览器把我们输入的数据封装在一个请求包中，服务器按照协议，将这个请求包解析出来。

在 JavaScript 中，可以使用 fetch API 来发送 GET 和 POST 请求，如下所示：

```javascript
// GET 请求
fetch("https://example.com", {
  method: "GET",
})
  .then((response) => response.json())
  .then((data) => console.log(data))
  .catch((error) => console.error("Error:", error));

// POST 请求
fetch("https://example.com", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
  },
  body: JSON.stringify({
    key: "value",
  }),
})
  .then((response) => response.json())
  .then((data) => console.log(data))
  .catch((error) => console.error("Error:", error));
```

## HTTPS 协议

超文本传输安全协议（Hypertext Transfer Protocol Secure，简称：HTTPS）是一种通过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，利用 SSL/TLS 来加密数据包。HTTPS 的主要目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。

## HTTP 安全风险

- 信息窃听 -> 信息加密 -> 对称加密 AES
- 密钥传递 -> 密钥协商 -> 非对称加密 RSA/ECC
- 信息篡改 -> 完整性校验 -> 散列算法 MD5/SHA
- 身份冒充 -> CA 权威机构 -> 散列算法 MD5/SHA

### TLS/SSL

TLS/SSL 全称安全传输层协议（Transport Layer Security）, 是介于 TCP 和 HTTP 之间的一层安全协议，不影响原有的 TCP 协议和 HTTP
协议，所以使用 HTTPS 基本上不需要对 HTTP 页面进行太多的改造。 TLS/SSL 的功能实现主要依赖三类基本算法：散列函数 hash、对称加密、非对称加密。这三类算法的作用如下：

- 基于散列函数验证信息的完整性
- 对称加密算法采用协商的秘钥对数据加密
- 非对称加密实现身份认证和秘钥协商

综合上述算法特点，TLS/SSL 的工作方式就是客户端使用非对称加密与服务器进行通信，实现身份的验证并协商对称加密使用的秘钥。对称加密算法采用协商秘钥对信息以及信息摘要进行加密通信，不同节点之间采用的对称秘钥不同，从而保证信息只能通信双方获取。这样就解决了两个方法各自存在的问题。

### 散列函数 hash

常见的散列函数有 MD5、SHA1、SHA256。该函数的特点是单向不可逆，对输入数据非常敏感，输出的长度固定，任何数据的修改都会改变散列函数的结果，**可以用于验证数据的完整性**，在信息传输过程中，散列函数不能实现信息防篡改，由于传输是明文传输，中间人可以修改信息后重新计算信息的摘要，所以需要对传输的信息和信息摘要进行加密。

### 对称加密

对称加密的方法是，双方使用同一个秘钥对数据进行加密和解密。但是对称加密的存在一个问题，就是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。这就要用到非对称加密的方法。常见的对称加密算法有 AES-CBC、DES、3DES、AES-GCM 等。相同的秘钥可以用于信息的加密和解密。掌握秘钥才能获取信息，防止信息窃听，其通讯方式是一对一。

特点：对称加密的优势就是信息传输使用一对一，需要共享相同的密码，密码的安全是保证信息安全的基础，服务器和 N 个客户端通信，需要维持 N 个密码记录且不能修改密码。

### 非对称加密

非对称加密的方法是，我们拥有两个秘钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户，都可以使用我们提供的公钥对数据进行加密，这样我们就可以使用私钥进行解密，这样就能保证数据的安全了。但是非对称加密有一个缺点就是加密的过程很慢，因此如果每次通信都使用非对称加密的方式的话，反而会造成等待时间过长的问题。

常见的非对称加密算法有 RSA、ECC、DH 等。秘钥成对出现，一般称为公钥（公开）和私钥（保密）。公钥加密的信息只有私钥可以解开，私钥加密的信息只能公钥解开，因此掌握公钥的不同客户端之间不能相互解密信息，只能和服务器进行加密通信，服务器可以实现一对多的的通信，客户端也可以用来验证掌握私钥的服务器的身份。

特点：非对称加密的特点就是信息一对多，服务器只需要维持一个私钥就可以和多个客户端进行通信，但服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，加密的速度慢。

### 数字证书

现在的方法也不一定是安全的，因为没有办法确定得到的公钥就一定是安全的公钥。可能存在一个中间人，截取了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而自己还不知道。为了解决这样的问题，可以使用数字证书。

首先使用一种 Hash 算法来对公钥和其他信息进行加密，生成一个信息摘要，然后让有公信力的认证中心（简称 CA ）用它的私钥对消息摘要加密，形成签名。最后将原始的信息和签名合在一起，称为数字证书。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和生成的摘要进行对比，就能发现得到的信息是否被更改了。这个方法最要的是认证中心的可靠性，一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有这样才能保证数据的安全。

我们把证书原本的内容生成一份“签名”，比对证书内容和签名是否一致就能判别是否被篡改。这就是数字证书的“防伪技术”，这里的“签名”就叫数字签名。假设中间人篡改了证书的原文，由于他没有 CA 机构的私钥，所以无法得到此时加密后签名，无法相应地篡改签名。浏览器收到该证书后会发现原文和签名解密后的值不一致，则说明证书已被篡改，证书不可信，从而终止向服务器传输信息，防止信息泄露给中间人。

假设有另一个网站 B 也拿到了 CA 机构认证的证书，它想劫持网站 A 的信息。于是它成为中间人拦截到了 A 传给浏览器的证书，然后替换成自己的证书，传给浏览器，之后浏览器就会错误地拿到 B 的证书里的公钥了，这确实会导致上文“中间人攻击”那里提到的漏洞？其实这并不会发生，因为证书里包含了网站 A 的信息，包括域名，浏览器把证书里的域名与自己请求的域名比对一下就知道有没有被掉包了。

### HTTPS 握手过程

HTTPS 握手过程，也被称为"TLS 握手"，是在客户端和服务器之间建立安全连接的过程。以下是详细的步骤：

1. 客户端发送"Client Hello"消息到服务器，消息中包含了客户端支持的加密方法，以及一个客户端生成的随机数。

2. 服务器回应一个"Server Hello"消息到客户端，消息中包含了服务器决定使用的加密方法，以及一个服务器生成的随机数。此外，服务器还会发送自己的证书（如果需要的话还会要求客户端的证书）。

3. 客户端收到服务器的证书并验证其有效性。验证包括检查证书是否过期，证书的颁发机构是否可信，以及证书中的域名是否和服务器的域名一致。

4. 客户端使用从服务器证书中获取的公钥来加密一个新的随机数，然后发送这个加密的随机数到服务器，这个随机数用于后续的对称加密。

5. 服务器使用自己的私钥来解密客户端发送过来的随机数。

6. 客户端和服务器现在都有了相同的三个随机数，然后双方使用这三个随机数通过一个密钥生成算法（如 RSA 或 ECC）来生成对话密钥，用于接下来的会话加密。

7. 客户端发送一个"Finished"消息给服务器，消息中包含一个前面所有握手消息的 hash 值，用于服务器验证。

8. 服务器也发送一个"Finished"消息给客户端，消息中同样包含一个前面所有握手消息的 hash 值，用于客户端验证。

9. 握手结束，客户端和服务器开始使用相同的对话密钥进行加密和解密数据，进行安全的信息传输。

这个过程中的任何一步如果失败，例如证书验证失败，那么握手就会失败，连接就会被关闭。

## http1.0 和 http1.1 的区别

- 连接方面，http1.0 默认使用非持久连接，而 http1.1 默认使用持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。

- 资源请求方面，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。

- 缓存方面，在 http1.0 中主要使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。

- http1.1 中新增了 host 字段，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个 IP 地址。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站。

- http1.1 相对于 http1.0 还新增了很多请求方法，如 PUT、HEAD、OPTIONS 等。

## http1.1 和 http2.0 的区别

- 二进制协议：HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。

- 多路复用：HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了"队头堵塞"的问题。

- 数据流：HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流。

- 头信息压缩：HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。

- 服务器推送：HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。
