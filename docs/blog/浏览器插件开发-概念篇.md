---
create_time: 2024-04-15 22:33:44
---

# 浏览器插件开发-概念篇

> 浏览器插件是一种可以在浏览器中安装的软件，可以增强浏览器的功能。

## manifest.json

`manifest.json` 文件名**不可变**，每个扩展程序的根目录中都必须有一个 `manifest.json` 文件。该清单会记录重要元数据、定义资源、声明权限以及标识在后台和网页中运行的文件。

```json5
{
  name: "My Extension", // 扩展程序名称
  version: "1.0", // 扩展程序版本
  manifest_version: 3, // 清单版本，必须为 3
  description: "description", // 扩展程序描述
  author: "god_wei", // 扩展程序作者
  icons: {
    // 扩展程序的图标
    "16": "images/get_started16.png",
    "48": "images/get_started48.png",
    "128": "images/get_started128.png",
  },
  action: {
    // 定义扩展程序图标在 Google 工具栏弹框
    default_popup: "popup.html",
    default_icon: {
      "16": "images/get_started16.png",
      "48": "images/get_started48.png",
      "128": "images/get_started128.png",
    },
  },
  background: {
    // 指定包含扩展程序的 Service Worker 的 JavaScript 文件，该 Service Worker 充当事件处理脚本
    service_worker: "background.js",
  },
  content_scripts: [
    // 指定用户打开特定网页时要使用的 JavaScript 或 CSS 文件 页面。
    {
      matches: ["<all_urls>"],
      js: ["content.js"],
      css: [],
    },
  ],
  browser_action: {
    default_popup: "popup.html",
    default_icon: {
      "16": "images/get_started16.png",
      "48": "images/get_started48.png",
      "128": "images/get_started128.png",
    },
  },
  chrome_url_overrides: {
    // 替换 Chrome 网页
    newtab: "new-tab.html",
  },
  web_accessible_resources: ["images/*.png"], // 定义扩展名内可通过网页或其他工具访问的文件
  declarative_net_request: {}, // 定义 declarativeNetRequest 的静态规则 API：用于屏蔽和修改网络请求。
  devtools_page: {}, // 定义使用 DevTools API 的页面。
  homepage_url: "", // 一个字符串，用于指定扩展程序的首页网址
  host_permissions: ["http://www.example.com/"], // 用于列出您的扩展程序可以与之互动的网页，使用 网址匹配模式。
  optional_host_permissions: [], // 声明可选的host权限 。
  optional_permissions: ["tabs"], // 为扩展程序声明可选权限。
  options_page: "", // 指定 options.html 文件的路径
  permissions: ["storage", "activeTab"], // 允许使用特定的扩展程序 API。
  side_panel: {}, //用于标识要在以下位置显示的 HTML 文件
  storage: {}, // 声明托管存储的 JSON 架构区域
}
```

## Service Worker

Service Worker 是充当扩展程序的主要事件处理程序的后台脚本。无权访问 DOM。

### 注册

> 要注册扩展 Service Worker，请在 manifest.json 文件的 "background" 字段中指定它。使用 "service_worker" 键，该键会指定单个 JavaScript 文件。

```json5
{
  name: "Awesome Test Extension",
  background: {
    service_worker: "service-worker.js",
  },
}
```

将脚本导入 Service Worker 的方法有两种：import 语句和 importScripts() 方法。请注意，如需使用 import 语句，请将 "type" 字段添加到您的清单中并指定 "module"。

```json5
{
  background: {
    service_worker: "service-worker.js",
    type: "module",
  },
}
```

然后，像往常一样使用。

```js
// 1. import 语句
import { sum } from "./test.js";

// 2. importScripts() 方法
importScripts("test.js");
```

## Content Scripts

内容脚本是在网页环境中运行 JavaScript，使用标准 Document 对象模型 (DOM) 结合使用，它们能够读取浏览器访问的网页的详细信息，对它们进行更改，并将信息传递给其父级扩展程序。内容脚本可以直接访问以下扩展程序 API，无法直接访问其他 API，但可以通过与扩展程序的其他部分互发消息来间接访问这些信息（通信篇将会介绍）。

- dom
- i18n
- storage
- runtime.connect()
- runtime.getManifest()
- runtime.getURL()
- runtime.id
- runtime.onConnect
- runtime.onMessage
- runtime.sendMessage()

您也可以使用 API，例如 fetch()，但需要在 manifest.json 文件中声明权限和配置。

### 静态声明进行注入

```json5
{
  name: "My extension",
  content_scripts: [
    {
      matches: ["https://*.nytimes.com/*"], // 	必需。指定要将此内容脚本注入哪些页面。
      css: ["my-styles.css"], // 要注入到匹配页面的 CSS 文件列表。这些是 在构建或显示任何 DOM 之前，按照它们在此数组中出现的顺序注入 。
      js: ["content-script.js"], // 要注入到匹配页面的 JavaScript 文件的列表。文件极客 会按照它们在此数组中出现的顺序进行注入。此列表中的每个字符串都必须包含 扩展程序根目录中资源的相对路径。
      run_at: "document_start", // 指定应在何时将脚本注入网页。默认值为 document_idle。
      match_about_blank: false, // 脚本是否应注入到 about:blank 帧中 其中的父框架或 Opener 框架与 matches。默认值为 false。
      exclude_matches: ["*://*/*business*"], // 不包括本内容脚本本应注入的网页 。可使用 通配符* ?。问号 (?) 匹配任意单个字符
      include_globs: ["*nytimes.com/???s/*"], // 在 matches之后应用，以便仅包含那些同时符合 匹配此 glob。可使用通配符* ?。
      exclude_globs: ["*science*"], // 在 matches之后应用，以排除匹配此值的网址 glob.可使用通配符* ?。
      all_frames: true, // 允许扩展程序指定是否应将 JavaScript 文件和 CSS 文件 注入到符合指定网址要求的所有帧中，或仅注入到 标签页。注入到子框架中。默认值为 false。
      match_origin_as_fallback: true, // 当扩展想要注入具有 about：、data：、blob： 和 filesystem：方案的 URL 的帧时，就会出现这种情况。在这些情况下，URL 将与内容脚本的模式不匹配.要注入到这些框架中，扩展可以在清单中的内容脚本规范上指定 “match_origin_as_fallback” 属性。优先级大于match_about_blank
    },
  ],
}
```

run_at: 脚本运行时刻，有以下 3 个选项：

- document_idle，默认；浏览器会选择一个合适的时间注入，并是在 dom 完成加载
- document_start；css 加载完成，dom 和脚本加载之前注入。
- document_end：dom 加载完成之后

#### 匹配规则

```js
<scheme>://<host>/<path>
```

scheme 可以是 `http`、`https`、通配符 _，仅与 http 或 https 匹配、`file`
host：主机名。 _ 用于匹配子网域 (_.example.com)，或仅使用通配符 _。
如果在 host 中使用通配符，它必须是第一个或唯一字符，并且后面必须跟一个句点 (.) 或正斜杠 (/)。

- `*` 表示 0 个或多个字符
- `?` 表示 1 个字符
- "<all_urls>" 表示所有 URL。

例子：匹配

```json5
{
  name: "My extension",
  content_scripts: [
    {
      matches: ["*//example-*.baidu.com/*"],
    },
  ],
}
```

> 报错了，为什么呢？因为如果在 host 中使用通配符，它必须是第一个或唯一字符，并且后面必须跟一个句点 (.) 或正斜杠 (/)。
> _//_.example.com ， https://_/foo_ 都可以。
> 解决办法使用 include_globs

### 使用动态声明进行注入

> 当内容脚本的匹配模式未知或不应总是在已知主机上注入内容脚本的情况。

1. 注册内容脚本。
2. 获取已注册内容脚本的列表。
3. 更新已注册内容脚本的列表。
4. 移除已注册的内容脚本。

注册内容脚本。

```js
chrome.scripting
  .registerContentScripts([
    {
      id: "session-script",
      js: ["content.js"],
      persistAcrossSessions: false,
      matches: ["*://example.com/*"],
      runAt: "document_start",
    },
  ])
  .then(() => console.log("registration complete"))
  .catch((err) => console.warn("unexpected error", err));
```

获取已注册内容脚本的列表。

```js
chrome.scripting
  .getRegisteredContentScripts()
  .then((scripts) => console.log("registered content scripts", scripts));
```

更新已注册内容脚本的列表。

```js
chrome.scripting
  .updateContentScripts([
    {
      id: "session-script",
      excludeMatches: ["*://admin.example.com/*"],
    },
  ])
  .then(() => console.log("registration updated"));
```

移除已注册的内容脚本。

```js
chrome.scripting
  .unregisterContentScripts({ ids: ["session-script"] })
  .then(() => console.log("un-registration complete"));
```

### 以编程方式注入

> 对于需要为响应事件或特定事件而运行的内容脚本，请使用程序化注入 。

首先需要添加 "permissions": ["activeTab","scripting"]

请注意，注入的函数是 chrome.scripting.executeScript() 调用，而不是原始函数本身。因此，函数的上下文必须保持独立；引用函数之外的变量会导致内容脚本来抛出 ReferenceError。

```js
// 1. 内容脚本作为文件注入。service-worker.js
chrome.action.onClicked.addListener((tab) => {
  chrome.scripting.executeScript({
    target: { tabId: tab.id },
    files: ["content-script.js"],
  });
});

// 2. 函数正文也可以作为内容脚本进行注入和执行。
function injectedFunction() {
  document.body.style.backgroundColor = "orange";
}

// service-worker.js
chrome.action.onClicked.addListener((tab) => {
  chrome.scripting.executeScript({
    target: { tabId: tab.id },
    func: injectedFunction,
  });
});

function injectedFunction(color) {
  document.body.style.backgroundColor = color;
}

// service-worker.js 传递参数
chrome.action.onClicked.addListener((tab) => {
  chrome.scripting.executeScript({
    target: { tabId: tab.id },
    func: injectedFunction,
    args: ["orange"],
  });
});
```

尽管内容脚本的执行环境和托管它们的页面彼此隔离，但它们共享对页面 DOM 的访问。如果页面希望与内容脚本通信，或通过内容脚本与扩展通信，则必须通过共享 DOM 进行通信。

```js
// content-script.js
var port = chrome.runtime.connect();

window.addEventListener(
  "message",
  (event) => {
    // We only accept messages from ourselves
    if (event.source !== window) {
      return;
    }

    if (event.data.type && event.data.type === "FROM_PAGE") {
      console.log("Content script received: " + event.data.text);
      port.postMessage(event.data.text);
    }
  },
  false
);

// example.js
document.getElementById("theButton").addEventListener(
  "click",
  () => {
    window.postMessage({ type: "FROM_PAGE", text: "Hello from the webpage!" }, "*");
  },
  false
);
```

要从内容脚本访问扩展程序的文件，您可以调用 chrome.runtime.getURL 来获取扩展资源的绝对路径，所有资源都必须在 manifest.json 文件中声明为 web_accessible_resources

```js
let image = chrome.runtime.getURL("images/my_image.png");
```

要在 CSS 文件中使用字体或图像，可以使用 @@extension_id 构建 URL

```css
body {
  background-image: url("chrome-extension://__MSG_@@extension_id__/background.png");
}

@font-face {
  font-family: "Stint Ultra Expanded";
  font-style: normal;
  font-weight: 400;
  src: url("chrome-extension://__MSG_@@extension_id__/fonts/Stint Ultra Expanded.woff") format("woff");
}
```

## action

在用户点击扩展程序工具栏图标或使用 Action API 显示弹出式窗口时，执行代码。

```json5
{
  name: "Action Extension",
  action: {
    default_icon: {
      // 图标
      "16": "images/icon16.png", // optional
      "24": "images/icon24.png", // optional
      "32": "images/icon32.png", // optional
    },
    default_title: "Click Me", // 标题，当用户将鼠标指针悬停在工具栏中扩展的图标上时，将显示工具提示或标题。
    default_popup: "popup.html", // 页面，当用户单击工具栏中扩展的操作按钮时，会显示操作的弹出窗口。
    // 弹出窗口的大小必须介于 25x25 和 800x600 像素之间
  },
}
```

JS 操作

```js
// 1. 当用户单击工具栏中扩展的操作按钮时，会显示操作的弹出窗口。
chrome.action.onClicked.addListener((tab) => {
  chrome.scripting.executeScript({
    target: { tabId: tab.id },
    files: ["content-script.js"],
  });
});

// 2. 当用户将鼠标指针悬停在工具栏中扩展的图标上时，将显示工具提示或标题。
chrome.action.setTitle({ title: "New Title" });
```

## 侧边面板

在浏览器的侧边栏中显示自定义界面。

## new tab

## DEV tools

## 浏览器插件开发-通信

[浏览器插件开发-通信](./浏览器插件开发-通信篇.md)
